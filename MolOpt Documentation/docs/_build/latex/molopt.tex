%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsible pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{tgtermes}
\usepackage{tgheros}
\renewcommand{\ttdefault}{txtt}



\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=auto}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\contentsname}{Contents:}}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{1}



\title{MolOpt}
\date{Nov 03, 2021}
\release{}
\author{estevaopbs}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}



\chapter{MolOpt Documentation}
\label{\detokenize{modules:molopt-documentation}}\label{\detokenize{modules::doc}}

\section{MolOpt module}
\label{\detokenize{MolOpt:module-MolOpt}}\label{\detokenize{MolOpt:molopt-module}}\label{\detokenize{MolOpt::doc}}\index{module@\spxentry{module}!MolOpt@\spxentry{MolOpt}}\index{MolOpt@\spxentry{MolOpt}!module@\spxentry{module}}\index{MolOpt (class in MolOpt)@\spxentry{MolOpt}\spxextra{class in MolOpt}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MolOpt:MolOpt.MolOpt}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{MolOpt.}}\sphinxbfcode{\sphinxupquote{MolOpt}}}{\emph{\DUrole{n}{first\_molecule}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{molecular:molecular.Molecule}]{\sphinxcrossref{molecular.Molecule}}}}}, \emph{\DUrole{n}{fitness\_param}\DUrole{p}{:} \DUrole{n}{str}}, \emph{\DUrole{n}{strategies}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{genetic:genetic.Strategies}]{\sphinxcrossref{genetic.Strategies}}}}}, \emph{\DUrole{n}{max\_age}\DUrole{p}{:} \DUrole{n}{int}}, \emph{\DUrole{n}{pool\_size}\DUrole{p}{:} \DUrole{n}{int}}, \emph{\DUrole{n}{mutate\_after\_crossover}\DUrole{p}{:} \DUrole{n}{bool}}, \emph{\DUrole{n}{crossover\_elitism}\DUrole{p}{:} \DUrole{n}{list\DUrole{p}{{[}}int\DUrole{p}{{]}}}}, \emph{\DUrole{n}{elitism\_rate}\DUrole{p}{:} \DUrole{n}{list\DUrole{p}{{[}}int\DUrole{p}{{]}}}}, \emph{\DUrole{n}{freedom\_rate}\DUrole{p}{:} \DUrole{n}{int}}, \emph{\DUrole{n}{parallelism}\DUrole{p}{:} \DUrole{n}{bool}}, \emph{\DUrole{n}{local\_opt}\DUrole{p}{:} \DUrole{n}{bool}}, \emph{\DUrole{n}{max\_seconds}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}Union\DUrole{p}{{[}}int\DUrole{p}{, }float\DUrole{p}{{]}}\DUrole{p}{{]}}}}, \emph{\DUrole{n}{time\_toler}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}Union\DUrole{p}{{[}}int\DUrole{p}{, }float\DUrole{p}{{]}}\DUrole{p}{{]}}}}, \emph{\DUrole{n}{gens\_toler}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}int\DUrole{p}{{]}}}}, \emph{\DUrole{n}{max\_gens}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}int\DUrole{p}{{]}}}}, \emph{\DUrole{n}{save\_directory}\DUrole{p}{:} \DUrole{n}{str}}, \emph{\DUrole{n}{threads\_per\_calc}\DUrole{p}{:} \DUrole{n}{int}}}{}
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{genetic:genetic.Genetic}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{genetic.Genetic}}}}}

\sphinxAtStartPar
Molecular geometry optimization class
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{Genetic}} (\sphinxstyleliteralemphasis{\sphinxupquote{ABC}}) \textendash{} Genetic algorithm abstract class

\end{description}\end{quote}

\sphinxAtStartPar
Initializes the MolOpt object
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{first\_molecule}} ({\hyperref[\detokenize{molecular:molecular.Molecule}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Molecule}}}}}) \textendash{} Molecule which is wanted to be optimized

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{fitness\_param}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} The string which precedes the energy value in Molpro’s output

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{strategies}} ({\hyperref[\detokenize{genetic:genetic.Strategies}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Strategies}}}}}) \textendash{} Strategies object

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{max\_age}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} The max amount of times a Chromosome can suffer chaging strategies without improve its fitness

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{pool\_size}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} The amount of candidates being optimized simultaneously

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mutate\_after\_crossover}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} If it’s True, than after each crossover operation, the resultant child Chromosome
suffer a mutate operation before return to the genetic algorithm, but if it’s false the mutation doesn’t
occur and the child Chromosome is returned immediately after the crossover

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{crossover\_elitism}} (\sphinxstyleliteralemphasis{\sphinxupquote{Union}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{numeric}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} The rate each candidate tends to be selected to be the gene’s donor in any crossover
operation from the best to the worst. Its lenght must be equal pool\_size value. If pool\_size is 3 and
crossover\_elitism is {[}3, 2, 1{]} the best candidate has the triple of the chance to be selected than the
worst, the medium candidate has double. It can also receive None, and it means all candidates are equally
probable to be selected for being the genes’ donor on a crossover

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{elitism\_rate}} (\sphinxstyleliteralemphasis{\sphinxupquote{Union}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} list of reprodution rate of each candidate, from the best to the worst. the sum of its
elements also must be less or equal than pool\_size. If pool\_size is 16 and elitism\_rate is {[}4, 3, 2{]} it
means the best candidate in the current generation’s pool of candidates will provide 4 descendants for the
next generation, the second best will provide 3 and the third best will provide two, then then remain 7
available spaces in the next generation’s pool will be filled with one descendant of each of the next seven
candidates in this order

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{freedom\_rate}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} The number of candidate generation strategies (Mutate, Crossover and Create) the candidate
will suffer aways a new candidate is needed to be generated (if Create is selected it means the candidate is
supposed to be substituted by a whole new one without any relation with the parent candidate)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{parallelism}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} If it’s True than each fitness calculation will be done in a different process, what changes
the whole dynamics of the genetic algorithm. With paraellism enabled, the concept of generations emerges as
we can have different candidates being caculated at the same time. If it’s False, there will be no
generations and candidates’ fitnesses will be calculated sequentially

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{local\_opt}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} If its True makes that every time the algorithm genetic gets a new best candidate it is sent
to the local\_optimize function (which in this case must be override by the subclass) that is supposed to
perform a local optimization (in the solution\sphinxhyphen{}space of the specific problem) over the genes of the best
candidate, and then return a new best candidate with the optimized genes

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{max\_seconds}} (\sphinxstyleliteralemphasis{\sphinxupquote{Union}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{numeric}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} The max amount of seconds the genetic algorithm can run. Once exceeded this amount, the
the running will be stoped and the best candidate will be returned. It can also receive None, and in this
case this limit wouldn’t exist

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{time\_toler}} (\sphinxstyleliteralemphasis{\sphinxupquote{Union}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{numeric}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} The max amount of seconds the algorithm can still running without has any improvements on its
best candidate’s fitness. Once exceeded this amount, the running will be stoped and the best candidate will
be returned. It can also receive None, and in this case this limit wouldn’t exist

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{gens\_toler}} (\sphinxstyleliteralemphasis{\sphinxupquote{Union}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{numeric}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} The maximum amount of generations the algorithm genetic can run in sequence without having
any improvement on it’s best parent fitness. It can also receive None and in this case this limit wouldn’t
exist. It only works when parallelism is True, otherwise it doesn’t affect anything

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{max\_gens}} (\sphinxstyleliteralemphasis{\sphinxupquote{Union}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{numeric}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} The max amount of generations the genetic algorithm can run. Once exceeded this amount, the
the running will be stoped and the best candidate will be returned. It can also receive None, and in this
case this limit wouldn’t exist. It only works when parallelism is True, otherwise it doesn’t affect anything

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{save\_directory}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} The directory address relative to \_\_main\_\_ where the outputs will be saved. If its None
than it will receive the instant of time the running started

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{threads\_per\_calc}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of threads useds in each Molpro calculation

\end{itemize}

\end{description}\end{quote}
\index{catch() (MolOpt.MolOpt static method)@\spxentry{catch()}\spxextra{MolOpt.MolOpt static method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MolOpt:MolOpt.MolOpt.catch}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxbfcode{\sphinxupquote{catch}}}{\emph{\DUrole{n}{candidate}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{genetic:genetic.Chromosome}]{\sphinxcrossref{genetic.Chromosome}}}}}}{{ $\rightarrow$ None}}
\sphinxAtStartPar
Static method which will be executed if an error occurs during a candidate generation
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{candidate}} ({\hyperref[\detokenize{genetic:genetic.Chromosome}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Chromosome}}}}}) \textendash{} Candidate which during generation some exception occurred

\end{description}\end{quote}

\end{fulllineitems}

\index{crossover\_1() (MolOpt.MolOpt static method)@\spxentry{crossover\_1()}\spxextra{MolOpt.MolOpt static method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MolOpt:MolOpt.MolOpt.crossover_1}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxbfcode{\sphinxupquote{crossover\_1}}}{\emph{\DUrole{n}{parent}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{genetic:genetic.Chromosome}]{\sphinxcrossref{genetic.Chromosome}}}}}, \emph{\DUrole{n}{donor}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{genetic:genetic.Chromosome}]{\sphinxcrossref{genetic.Chromosome}}}}}}{{ $\rightarrow$ {\hyperref[\detokenize{molecular:molecular.Molecule}]{\sphinxcrossref{molecular.Molecule}}}}}
\sphinxAtStartPar
Produces a new molecule with the crossover of parent’s and donor’s molecules by cutting each one in one point
and combining the resultant pieces.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{parent}} ({\hyperref[\detokenize{genetic:genetic.Chromosome}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Chromosome}}}}}) \textendash{} Candidate which Molecule will suffer crossover\_1

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{donor}} ({\hyperref[\detokenize{genetic:genetic.Chromosome}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Chromosome}}}}}) \textendash{} Candidate which will donate parameters for the crossover\_1 operation

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
Child molecule

\item[{Return type}] \leavevmode
\sphinxAtStartPar
{\hyperref[\detokenize{molecular:molecular.Molecule}]{\sphinxcrossref{Molecule}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{crossover\_2() (MolOpt.MolOpt static method)@\spxentry{crossover\_2()}\spxextra{MolOpt.MolOpt static method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MolOpt:MolOpt.MolOpt.crossover_2}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxbfcode{\sphinxupquote{crossover\_2}}}{\emph{\DUrole{n}{parent}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{genetic:genetic.Chromosome}]{\sphinxcrossref{genetic.Chromosome}}}}}, \emph{\DUrole{n}{donor}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{genetic:genetic.Chromosome}]{\sphinxcrossref{genetic.Chromosome}}}}}}{{ $\rightarrow$ {\hyperref[\detokenize{molecular:molecular.Molecule}]{\sphinxcrossref{molecular.Molecule}}}}}
\sphinxAtStartPar
Produces a new molecule with the crossover of parent’s and donor’s molecules by cutting each one in two
points and combining the resultant pieces
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{parent}} ({\hyperref[\detokenize{genetic:genetic.Chromosome}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Chromosome}}}}}) \textendash{} Candidate which Molecule will suffer crossover\_1

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{donor}} ({\hyperref[\detokenize{genetic:genetic.Chromosome}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Chromosome}}}}}) \textendash{} Candidate which will donate parameters for the crossover\_1 operation

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
Child molecule

\item[{Return type}] \leavevmode
\sphinxAtStartPar
{\hyperref[\detokenize{molecular:molecular.Molecule}]{\sphinxcrossref{Molecule}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{crossover\_n() (MolOpt.MolOpt static method)@\spxentry{crossover\_n()}\spxextra{MolOpt.MolOpt static method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MolOpt:MolOpt.MolOpt.crossover_n}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxbfcode{\sphinxupquote{crossover\_n}}}{\emph{\DUrole{n}{parent}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{genetic:genetic.Chromosome}]{\sphinxcrossref{genetic.Chromosome}}}}}, \emph{\DUrole{n}{donor}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{genetic:genetic.Chromosome}]{\sphinxcrossref{genetic.Chromosome}}}}}}{{ $\rightarrow$ {\hyperref[\detokenize{molecular:molecular.Molecule}]{\sphinxcrossref{molecular.Molecule}}}}}
\sphinxAtStartPar
Returns a new molecule which randomly carries parameters from the parent’s and donor’s molecules
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{parent}} ({\hyperref[\detokenize{genetic:genetic.Chromosome}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Chromosome}}}}}) \textendash{} Candidate which Molecule will suffer crossover\_1

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{donor}} ({\hyperref[\detokenize{genetic:genetic.Chromosome}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Chromosome}}}}}) \textendash{} Candidate which will donate parameters for the crossover\_1 operation

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
Child molecule

\item[{Return type}] \leavevmode
\sphinxAtStartPar
{\hyperref[\detokenize{molecular:molecular.Molecule}]{\sphinxcrossref{Molecule}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_fitness() (MolOpt.MolOpt method)@\spxentry{get\_fitness()}\spxextra{MolOpt.MolOpt method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MolOpt:MolOpt.MolOpt.get_fitness}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_fitness}}}{\emph{\DUrole{n}{candidate}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{genetic:genetic.Chromosome}]{\sphinxcrossref{genetic.Chromosome}}}}}}{{ $\rightarrow$ float}}
\sphinxAtStartPar
Receives a candidate’s Chromosome and returns its fitness
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{candidate}} ({\hyperref[\detokenize{genetic:genetic.Chromosome}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Chromosome}}}}}) \textendash{} Candidate which fitness must be calculated

\item[{Returns}] \leavevmode
\sphinxAtStartPar
Candidate’s fitness

\item[{Return type}] \leavevmode
\sphinxAtStartPar
float

\end{description}\end{quote}

\end{fulllineitems}

\index{local\_optimize() (MolOpt.MolOpt method)@\spxentry{local\_optimize()}\spxextra{MolOpt.MolOpt method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MolOpt:MolOpt.MolOpt.local_optimize}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{local\_optimize}}}{\emph{\DUrole{n}{candidate}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{genetic:genetic.Chromosome}]{\sphinxcrossref{genetic.Chromosome}}}}}}{{ $\rightarrow$ {\hyperref[\detokenize{molecular:molecular.Molecule}]{\sphinxcrossref{molecular.Molecule}}}}}
\sphinxAtStartPar
Executes geometric optimization over the candidate’s molecule using Molpro and returns a new molecule with
the optimized geometry
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{candidate}} ({\hyperref[\detokenize{genetic:genetic.Chromosome}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Chromosome}}}}}) \textendash{} Candidate which Molecule will suffer local\_optimize operation

\item[{Returns}] \leavevmode
\sphinxAtStartPar
Optimized molecule

\item[{Return type}] \leavevmode
\sphinxAtStartPar
{\hyperref[\detokenize{molecular:molecular.Molecule}]{\sphinxcrossref{Molecule}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{mutate\_angles() (MolOpt.MolOpt static method)@\spxentry{mutate\_angles()}\spxextra{MolOpt.MolOpt static method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MolOpt:MolOpt.MolOpt.mutate_angles}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxbfcode{\sphinxupquote{mutate\_angles}}}{\emph{\DUrole{n}{parent}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{genetic:genetic.Chromosome}]{\sphinxcrossref{genetic.Chromosome}}}}}}{{ $\rightarrow$ {\hyperref[\detokenize{molecular:molecular.Molecule}]{\sphinxcrossref{molecular.Molecule}}}}}
\sphinxAtStartPar
Returns parent’s molecule’s copy with some random angle parameter randomized between 0 and 360 degrees
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{parent}} ({\hyperref[\detokenize{genetic:genetic.Chromosome}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Chromosome}}}}}) \textendash{} Candidate which Molecule will suffer mutate\_angles

\item[{Returns}] \leavevmode
\sphinxAtStartPar
New molecule

\item[{Return type}] \leavevmode
\sphinxAtStartPar
{\hyperref[\detokenize{molecular:molecular.Molecule}]{\sphinxcrossref{Molecule}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{mutate\_distances() (MolOpt.MolOpt static method)@\spxentry{mutate\_distances()}\spxextra{MolOpt.MolOpt static method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MolOpt:MolOpt.MolOpt.mutate_distances}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxbfcode{\sphinxupquote{mutate\_distances}}}{\emph{\DUrole{n}{parent}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{genetic:genetic.Chromosome}]{\sphinxcrossref{genetic.Chromosome}}}}}}{{ $\rightarrow$ {\hyperref[\detokenize{molecular:molecular.Molecule}]{\sphinxcrossref{molecular.Molecule}}}}}
\sphinxAtStartPar
Returns a parent’s molecule’s copy with some random distance parameter randomized in the range gave by
parent.genes.rand\_range
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{parent}} ({\hyperref[\detokenize{genetic:genetic.Chromosome}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Chromosome}}}}}) \textendash{} Candidate which Molecule will suffer mutate\_distances

\item[{Returns}] \leavevmode
\sphinxAtStartPar
New molecule

\item[{Return type}] \leavevmode
\sphinxAtStartPar
{\hyperref[\detokenize{molecular:molecular.Molecule}]{\sphinxcrossref{Molecule}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{randomize() (MolOpt.MolOpt static method)@\spxentry{randomize()}\spxextra{MolOpt.MolOpt static method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MolOpt:MolOpt.MolOpt.randomize}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxbfcode{\sphinxupquote{randomize}}}{\emph{\DUrole{n}{parent}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{genetic:genetic.Chromosome}]{\sphinxcrossref{genetic.Chromosome}}}}}}{{ $\rightarrow$ {\hyperref[\detokenize{molecular:molecular.Molecule}]{\sphinxcrossref{molecular.Molecule}}}}}
\sphinxAtStartPar
Returns a parent’s molecule’s copy with all distances and angles parameters randomized
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{parent}} ({\hyperref[\detokenize{genetic:genetic.Chromosome}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Chromosome}}}}}) \textendash{} Candidate which Molecule will suffer randomize operation

\item[{Returns}] \leavevmode
\sphinxAtStartPar
New molecule

\item[{Return type}] \leavevmode
\sphinxAtStartPar
{\hyperref[\detokenize{molecular:molecular.Molecule}]{\sphinxcrossref{Molecule}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{save() (MolOpt.MolOpt static method)@\spxentry{save()}\spxextra{MolOpt.MolOpt static method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MolOpt:MolOpt.MolOpt.save}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxbfcode{\sphinxupquote{save}}}{\emph{\DUrole{n}{candidate}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{genetic:genetic.Chromosome}]{\sphinxcrossref{genetic.Chromosome}}}}}, \emph{\DUrole{n}{file\_name}\DUrole{p}{:} \DUrole{n}{str}}, \emph{\DUrole{n}{directory}\DUrole{p}{:} \DUrole{n}{str}}}{{ $\rightarrow$ None}}
\sphinxAtStartPar
Saves the candidate data in a .inp document
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{candidate}} ({\hyperref[\detokenize{genetic:genetic.Chromosome}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Chromosome}}}}}) \textendash{} Candidate which data will be saved

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{file\_name}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Document’s name

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{directory}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Directory where the document will be saved

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{swap\_mutate() (MolOpt.MolOpt static method)@\spxentry{swap\_mutate()}\spxextra{MolOpt.MolOpt static method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MolOpt:MolOpt.MolOpt.swap_mutate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxbfcode{\sphinxupquote{swap\_mutate}}}{\emph{\DUrole{n}{parent}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{genetic:genetic.Chromosome}]{\sphinxcrossref{genetic.Chromosome}}}}}}{{ $\rightarrow$ {\hyperref[\detokenize{molecular:molecular.Molecule}]{\sphinxcrossref{molecular.Molecule}}}}}
\sphinxAtStartPar
Returns a parent’s molecule’s copy with randomly swapped places parameters
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{parent}} ({\hyperref[\detokenize{genetic:genetic.Chromosome}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Chromosome}}}}}) \textendash{} Candidate which Molecule will suffer swap\_mutate

\item[{Returns}] \leavevmode
\sphinxAtStartPar
New molecule

\item[{Return type}] \leavevmode
\sphinxAtStartPar
{\hyperref[\detokenize{molecular:molecular.Molecule}]{\sphinxcrossref{Molecule}}}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\section{genetic module}
\label{\detokenize{genetic:module-genetic}}\label{\detokenize{genetic:genetic-module}}\label{\detokenize{genetic::doc}}\index{module@\spxentry{module}!genetic@\spxentry{genetic}}\index{genetic@\spxentry{genetic}!module@\spxentry{module}}\index{Chromosome (class in genetic)@\spxentry{Chromosome}\spxextra{class in genetic}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{genetic:genetic.Chromosome}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{genetic.}}\sphinxbfcode{\sphinxupquote{Chromosome}}}{\emph{\DUrole{n}{genes}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}Any\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{fitness}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}Any\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{strategy}\DUrole{p}{:} \DUrole{n}{list{[}collections.abc.Callable{[}{[}\textasciitilde{} Chromosome{]}, \textasciitilde{} Genes{]}{]}} \DUrole{o}{=} \DUrole{default_value}{{[}{]}}}, \emph{\DUrole{n}{age}\DUrole{p}{:} \DUrole{n}{int} \DUrole{o}{=} \DUrole{default_value}{0}}, \emph{\DUrole{n}{lineage}\DUrole{p}{:} \DUrole{n}{list} \DUrole{o}{=} \DUrole{default_value}{{[}{]}}}, \emph{\DUrole{n}{label}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}str\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}}{}
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
Object that represents the candidates

\sphinxAtStartPar
Initializes the Chromosome object
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{genes}} (\sphinxstyleliteralemphasis{\sphinxupquote{Any}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} What is wanted to optimize

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{fitness}} (\sphinxstyleliteralemphasis{\sphinxupquote{Any}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Value which describes how much the genes fits what is wanted. It can be of any type since it
can be compared with \textgreater{} and \textless{} and can be printed

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{strategy}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{Callable}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}{\hyperref[\detokenize{genetic:genetic.Chromosome}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Chromosome}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{Genes}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Container which stores the functions used to obtain the current Chromosome, defaults to {[}{]}

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{age}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} How many times the candidate was modificated without having any improvement, defaults to 0

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{lineage}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}{\hyperref[\detokenize{genetic:genetic.Chromosome}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Chromosome}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} The historic of Chromosomes used to find the current Chromosome, defaults to {[}{]}

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{label}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} A tag which can be used to identify the Chromosome object, defaults to None, defaults to None

\end{itemize}

\end{description}\end{quote}
\index{strategy\_str (genetic.Chromosome property)@\spxentry{strategy\_str}\spxextra{genetic.Chromosome property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{genetic:genetic.Chromosome.strategy_str}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{strategy\_str}}\sphinxbfcode{\sphinxupquote{: str}}}
\sphinxAtStartPar
Returns a string which represents the list of the functions used to obtain the current Chromosome object
:return: String of a list of the names of the functions used to obtain the current Chromosome object
:rtype: str

\end{fulllineitems}


\end{fulllineitems}

\index{Create (class in genetic)@\spxentry{Create}\spxextra{class in genetic}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{genetic:genetic.Create}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{genetic.}}\sphinxbfcode{\sphinxupquote{Create}}}{\emph{\DUrole{n}{methods}\DUrole{p}{:} \DUrole{n}{list{[}collections.abc.Callable{[}{[}genetic.Chromosome{]}, \textasciitilde{} Genes{]}{]}}}, \emph{\DUrole{n}{methods\_rate}\DUrole{p}{:} \DUrole{n}{list\DUrole{p}{{[}}typing.Union\DUrole{p}{{[}}int\DUrole{p}{, }float\DUrole{p}{{]}}\DUrole{p}{{]}}}}}{}
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
A container for storing genes creation functions and its rates. When called it receives the first\_parent
Chromosome and returns a new Chromosome
This class is supposed to receive functions which receive a generic parent Chromosome and return a whole new genes
without any bound to the parent’s one. The exceptions are mutate\_best and mutate\_first, which respectively returns
a result of passing the best and the first parent, respectively to the mutate object
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
New Chromosome object with the created genes

\item[{Return type}] \leavevmode
\sphinxAtStartPar
{\hyperref[\detokenize{genetic:genetic.Chromosome}]{\sphinxcrossref{Chromosome}}}

\end{description}\end{quote}

\sphinxAtStartPar
Initializes the Crossover object by receiving its parameters
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{methods}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{Callable}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}{\hyperref[\detokenize{genetic:genetic.Chromosome}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Chromosome}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{Genes}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Functions which receives the first\_parent Chromosome and returns a new genes

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{methods\_rate}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{numeric}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} The rate the functions tends be randomly chosen when the Crossover object is called. It
must have the same lenght as methods. Suppose methods is {[}m1, m2, m3{]} and methods\_rate is  {[}1, 2, 3{]}. m2
tends to be chosen twice the m1 is and m3 thrice the m1 is.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{Crossover (class in genetic)@\spxentry{Crossover}\spxextra{class in genetic}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{genetic:genetic.Crossover}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{genetic.}}\sphinxbfcode{\sphinxupquote{Crossover}}}{\emph{\DUrole{n}{methods}\DUrole{p}{:} \DUrole{n}{list{[}collections.abc.Callable{[}{[}genetic.Chromosome{]}, \textasciitilde{} Genes{]}{]}}}, \emph{\DUrole{n}{methods\_rate}\DUrole{p}{:} \DUrole{n}{list\DUrole{p}{{[}}typing.Union\DUrole{p}{{[}}int\DUrole{p}{, }float\DUrole{p}{{]}}\DUrole{p}{{]}}}}}{}
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
A container for storing crossover functions and its rates. When called it receives two Chromosome objects and
returns a new Chromosome
This class is supposed to receive functions which receive two Chromosome objects and returns a random combination of
their genes
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
Child Chromosome

\item[{Return type}] \leavevmode
\sphinxAtStartPar
{\hyperref[\detokenize{genetic:genetic.Chromosome}]{\sphinxcrossref{Chromosome}}}

\end{description}\end{quote}

\sphinxAtStartPar
Initializes the Crossover object by receiving its parameters
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{methods}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{Callable}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}{\hyperref[\detokenize{genetic:genetic.Chromosome}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Chromosome}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Functions which receives two Chromosome objects and returns a new genes

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{methods\_rate}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{numeric}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} The rate the functions tends be randomly chosen when the Crossover object is called. It
must have the same lenght as methods. Suppose methods is {[}m1, m2, m3{]} and methods\_rate is  {[}1, 2, 3{]}. m2
tends to be chosen twice the m1 is and m3 thrice the m1 is.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{Genetic (class in genetic)@\spxentry{Genetic}\spxextra{class in genetic}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{genetic:genetic.Genetic}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{genetic.}}\sphinxbfcode{\sphinxupquote{Genetic}}}{\emph{\DUrole{n}{first\_genes}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{genetic:genetic.Chromosome}]{\sphinxcrossref{genetic.Chromosome}}}}}, \emph{\DUrole{n}{strategies}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{genetic:genetic.Strategies}]{\sphinxcrossref{genetic.Strategies}}}}}, \emph{\DUrole{n}{max\_age}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}int\DUrole{p}{{]}}}}, \emph{\DUrole{n}{pool\_size}\DUrole{p}{:} \DUrole{n}{int}}, \emph{\DUrole{n}{mutate\_after\_crossover}\DUrole{p}{:} \DUrole{n}{bool}}, \emph{\DUrole{n}{crossover\_elitism}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}list\DUrole{p}{{[}}typing.Union\DUrole{p}{{[}}int\DUrole{p}{, }float\DUrole{p}{{]}}\DUrole{p}{{]}}\DUrole{p}{{]}}}}, \emph{\DUrole{n}{elitism\_rate}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}list\DUrole{p}{{[}}int\DUrole{p}{{]}}\DUrole{p}{{]}}}}, \emph{\DUrole{n}{freedom\_rate}\DUrole{p}{:} \DUrole{n}{int}}, \emph{\DUrole{n}{parallelism}\DUrole{p}{:} \DUrole{n}{bool}}, \emph{\DUrole{n}{local\_opt}\DUrole{p}{:} \DUrole{n}{bool}}, \emph{\DUrole{n}{max\_seconds}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}Union\DUrole{p}{{[}}int\DUrole{p}{, }float\DUrole{p}{{]}}\DUrole{p}{{]}}}}, \emph{\DUrole{n}{time\_toler}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}Union\DUrole{p}{{[}}int\DUrole{p}{, }float\DUrole{p}{{]}}\DUrole{p}{{]}}}}, \emph{\DUrole{n}{gens\_toler}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}Union\DUrole{p}{{[}}int\DUrole{p}{, }float\DUrole{p}{{]}}\DUrole{p}{{]}}}}, \emph{\DUrole{n}{max\_gens}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}Union\DUrole{p}{{[}}int\DUrole{p}{, }float\DUrole{p}{{]}}\DUrole{p}{{]}}}}, \emph{\DUrole{n}{save\_directory}\DUrole{p}{:} \DUrole{n}{str}}}{}
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{abc.ABC}}

\sphinxAtStartPar
Genetic algorithm abstract class
This abstract class provides a framework for creating problem\sphinxhyphen{}specific genetic algorithms. To use it you must create
a class that inherits it. The class that inherits it must have at least two methods: get\_fitness and save.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ABC}} (\sphinxstyleliteralemphasis{\sphinxupquote{class}}) \textendash{} Helper class that provides a standard way to create an abstract class using inheritance.

\end{description}\end{quote}

\sphinxAtStartPar
Initializes the Genetic object by receiving its parameters
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{first\_genes}} ({\hyperref[\detokenize{genetic:genetic.Chromosome}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Chromosome}}}}}) \textendash{} The genes of the first candidate in the genetic algorithm

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{strategies}} ({\hyperref[\detokenize{genetic:genetic.Strategies}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Strategies}}}}}) \textendash{} Strategies object

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{max\_age}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} The max amount of times a Chromosome can suffer chaging strategies without improve its fitness

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{pool\_size}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} The amount of candidates being optimized simultaneously

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mutate\_after\_crossover}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} If it’s True, than after each crossover operation, the resultant child Chromosome
suffer a mutate operation before return to the genetic algorithm, but if it’s false the mutation doesn’t
occur and the child Chromosome is returned immediately after the crossover

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{crossover\_elitism}} (\sphinxstyleliteralemphasis{\sphinxupquote{Union}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{numeric}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} The rate each candidate tends to be selected to be the gene’s donor in any crossover
operation from the best to the worst. Its lenght must be equal pool\_size value. If pool\_size is 3 and
crossover\_elitism is {[}3, 2, 1{]} the best candidate has the triple of the chance to be selected than the
worst, the medium candidate has double. It can also receive None, and it means all candidates are equally
probable to be selected for being the genes’ donor on a crossover

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{elitism\_rate}} (\sphinxstyleliteralemphasis{\sphinxupquote{Union}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} List of reprodution rate of each candidate, from the best to the worst. the sum of its
elements also must be less or equal than pool\_size. If pool\_size is 16 and elitism\_rate is {[}4, 3, 2{]} it
means the best candidate in the current generation’s pool of candidates will provide 4 descendants for the
next generation, the second best will provide 3 and the third best will provide two, then then remain 7
available spaces in the next generation’s pool will be filled with one descendant of each of the next seven
candidates in this order

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{freedom\_rate}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} The number of candidate generation strategies (Mutate, Crossover and Create) the candidate
will suffer aways a new candidate is needed to be generated (if Create is selected it means the candidate is
supposed to be substituted by a whole new one without any relation with the parent candidate)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{parallelism}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} If it’s True than each fitness calculation will be done in a different process, what changes
the whole dynamics of the genetic algorithm. With paraellism enabled, the concept of generations emerges as
we can have different candidates being caculated at the same time. If it’s False, there will be no
generations and candidates’ fitnesses will be calculated sequentially

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{local\_opt}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} If its True makes that every time the algorithm genetic gets a new best candidate it is sent
to the local\_optimize function (which in this case must be override by the subclass) that is supposed to
perform a local optimization (in the solution\sphinxhyphen{}space of the specific problem) over the genes of the best
candidate, and then return a new best candidate with the optimized genes

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{max\_seconds}} (\sphinxstyleliteralemphasis{\sphinxupquote{Union}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{numeric}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} The max amount of seconds the genetic algorithm can run. Once exceeded this amount, the
the running will be stoped and the best candidate will be returned. It can also receive None, and in this
case this limit wouldn’t exist

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{time\_toler}} (\sphinxstyleliteralemphasis{\sphinxupquote{Union}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{numeric}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} The max amount of seconds the algorithm can still running without has any improvements on its
best candidate’s fitness. Once exceeded this amount, the running will be stoped and the best candidate will
be returned. It can also receive None, and in this case this limit wouldn’t exist

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{gens\_toler}} (\sphinxstyleliteralemphasis{\sphinxupquote{Union}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{numeric}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} The maximum amount of generations the algorithm genetic can run in sequence without having
any improvement on it’s best parent fitness. It can also receive None and in this case this limit wouldn’t
exist. It only works when parallelism is True, otherwise it doesn’t affect anything

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{max\_gens}} (\sphinxstyleliteralemphasis{\sphinxupquote{Union}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{numeric}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} The max amount of generations the genetic algorithm can run. Once exceeded this amount, the
the running will be stoped and the best candidate will be returned. It can also receive None, and in this
case this limit wouldn’t exist. It only works when parallelism is True, otherwise it doesn’t affect anything

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{save\_directory}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} The directory address relative to \_\_main\_\_ where the outputs will be saved. If its None
than it will receive the instant of time the running started

\end{itemize}

\end{description}\end{quote}
\index{catch() (genetic.Genetic static method)@\spxentry{catch()}\spxextra{genetic.Genetic static method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{genetic:genetic.Genetic.catch}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxbfcode{\sphinxupquote{catch}}}{\emph{\DUrole{n}{candidate}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{genetic:genetic.Chromosome}]{\sphinxcrossref{genetic.Chromosome}}}}}}{{ $\rightarrow$ None}}
\sphinxAtStartPar
Static method which will be executed if an error occurs during a candidate generation
It can be override if needed. By default it just raises an exception
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{candidate}} ({\hyperref[\detokenize{genetic:genetic.Chromosome}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Chromosome}}}}}) \textendash{} Candidate which was being generated while error occurs

\item[{Raises}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{Exception}} \textendash{} Raises exception if error occurs during candidate generation

\end{description}\end{quote}

\end{fulllineitems}

\index{display() (genetic.Genetic static method)@\spxentry{display()}\spxextra{genetic.Genetic static method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{genetic:genetic.Genetic.display}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxbfcode{\sphinxupquote{display}}}{\emph{\DUrole{n}{candidate}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{genetic:genetic.Chromosome}]{\sphinxcrossref{genetic.Chromosome}}}}}, \emph{\DUrole{n}{timediff}\DUrole{p}{:} \DUrole{n}{float}}}{{ $\rightarrow$ None}}
\sphinxAtStartPar
Generate what is printed on console everytime a new best candidate is reached
It can be override if needed
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{candidate}} ({\hyperref[\detokenize{genetic:genetic.Chromosome}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Chromosome}}}}}) \textendash{} Best candidate founded

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{timediff}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Time difference between the candidate is founded and the start of the execution

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_fitness() (genetic.Genetic method)@\spxentry{get\_fitness()}\spxextra{genetic.Genetic method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{genetic:genetic.Genetic.get_fitness}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{abstract }}\sphinxbfcode{\sphinxupquote{get\_fitness}}}{\emph{\DUrole{n}{candidate}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{genetic:genetic.Chromosome}]{\sphinxcrossref{genetic.Chromosome}}}}}}{{ $\rightarrow$ genetic.Fitness}}~\begin{description}
\item[{Abstract method which must be override by one which receives a candidate’s Chromosome and returns it’s}] \leavevmode
\sphinxAtStartPar
fitness

\end{description}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{candidate}} (\sphinxstyleliteralemphasis{\sphinxupquote{Fitness}}) \textendash{} Candidate wich fitness is wanted

\item[{Return type}] \leavevmode
\sphinxAtStartPar
Fitness

\end{description}\end{quote}

\end{fulllineitems}

\index{load() (genetic.Genetic method)@\spxentry{load()}\spxextra{genetic.Genetic method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{genetic:genetic.Genetic.load}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{load}}}{}{{ $\rightarrow$ {\hyperref[\detokenize{genetic:genetic.Chromosome}]{\sphinxcrossref{genetic.Chromosome}}}}}
\sphinxAtStartPar
Returns a candidate with the first\_genes and the fitness of the first\_parent
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
First candidate

\item[{Return type}] \leavevmode
\sphinxAtStartPar
{\hyperref[\detokenize{genetic:genetic.Chromosome}]{\sphinxcrossref{Chromosome}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{local\_optimize() (genetic.Genetic method)@\spxentry{local\_optimize()}\spxextra{genetic.Genetic method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{genetic:genetic.Genetic.local_optimize}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{local\_optimize}}}{\emph{\DUrole{n}{candidate}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{genetic:genetic.Chromosome}]{\sphinxcrossref{genetic.Chromosome}}}}}}{{ $\rightarrow$ genetic.Genes}}
\sphinxAtStartPar
This method must be override in case of local\_opt is True for a method which receives a candidate’s
Chromosome and returns its genes locally optimized
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{candidate}} ({\hyperref[\detokenize{genetic:genetic.Chromosome}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Chromosome}}}}}) \textendash{} Candidate which genes are wanted to be optimized

\item[{Raises}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{Exception}} \textendash{} Raises exception if this method was not override by the subclass

\item[{Returns}] \leavevmode
\sphinxAtStartPar
Optimized genes

\item[{Return type}] \leavevmode
\sphinxAtStartPar
Genes

\end{description}\end{quote}

\end{fulllineitems}

\index{mutate\_best() (genetic.Genetic method)@\spxentry{mutate\_best()}\spxextra{genetic.Genetic method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{genetic:genetic.Genetic.mutate_best}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{mutate\_best}}}{\emph{\DUrole{n}{best\_candidate}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{genetic:genetic.Chromosome}]{\sphinxcrossref{genetic.Chromosome}}}}}}{{ $\rightarrow$ genetic.Genes}}
\sphinxAtStartPar
The actual mutate\_best function
Creation function that receives the Chromosome of the best candidate and pass it to the Mutate object to return
the result
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{best\_candidate}} ({\hyperref[\detokenize{genetic:genetic.Chromosome}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Chromosome}}}}}) \textendash{} Best candidate

\item[{Returns}] \leavevmode
\sphinxAtStartPar
Mutated genes of the best candidate

\item[{Return type}] \leavevmode
\sphinxAtStartPar
genes

\end{description}\end{quote}

\end{fulllineitems}

\index{mutate\_first() (genetic.Genetic method)@\spxentry{mutate\_first()}\spxextra{genetic.Genetic method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{genetic:genetic.Genetic.mutate_first}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{mutate\_first}}}{\emph{\DUrole{n}{first\_parent}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{genetic:genetic.Chromosome}]{\sphinxcrossref{genetic.Chromosome}}}}}}{{ $\rightarrow$ genetic.Genes}}
\sphinxAtStartPar
The actual mutate\_first function
Creation function that receives the Chromosome of the first candidate and pass it to the Mutate object to return
the result
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{first\_parent}} ({\hyperref[\detokenize{genetic:genetic.Chromosome}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Chromosome}}}}}) \textendash{} First created candidate

\item[{Returns}] \leavevmode
\sphinxAtStartPar
Mutated genes of the first candidate

\item[{Return type}] \leavevmode
\sphinxAtStartPar
genes

\end{description}\end{quote}

\end{fulllineitems}

\index{run() (genetic.Genetic method)@\spxentry{run()}\spxextra{genetic.Genetic method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{genetic:genetic.Genetic.run}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{run}}}{}{{ $\rightarrow$ {\hyperref[\detokenize{genetic:genetic.Chromosome}]{\sphinxcrossref{genetic.Chromosome}}}}}
\sphinxAtStartPar
Starts the genetic algorithm execution
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
Best candidate

\item[{Return type}] \leavevmode
\sphinxAtStartPar
{\hyperref[\detokenize{genetic:genetic.Chromosome}]{\sphinxcrossref{Chromosome}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{save() (genetic.Genetic method)@\spxentry{save()}\spxextra{genetic.Genetic method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{genetic:genetic.Genetic.save}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{abstract }}\sphinxbfcode{\sphinxupquote{save}}}{\emph{\DUrole{n}{candidate}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{genetic:genetic.Chromosome}]{\sphinxcrossref{genetic.Chromosome}}}}}, \emph{\DUrole{n}{file\_name}\DUrole{p}{:} \DUrole{n}{str}}, \emph{\DUrole{n}{directory}\DUrole{p}{:} \DUrole{n}{str}}}{{ $\rightarrow$ None}}
\sphinxAtStartPar
Abstract method which must be override by one which receives a candidate, a file\_name and a directory
This method which overrides it must receive a candidate’s Chromosome, a string which is the name of the file
the candidate will be saved and a string which is the directory where it will be saved than this function must
save the candidate relevant informations in a document named as given in the directory given. The directory is
given relative to \_\_main\_\_
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{candidate}} ({\hyperref[\detokenize{genetic:genetic.Chromosome}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Chromosome}}}}}) \textendash{} Candidate which is wanted to save

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{file\_name}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Name of the file in which the candidate’s informations must be saved

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{directory}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Directory where the file with the candidate’s information must be saved

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{Mutate (class in genetic)@\spxentry{Mutate}\spxextra{class in genetic}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{genetic:genetic.Mutate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{genetic.}}\sphinxbfcode{\sphinxupquote{Mutate}}}{\emph{\DUrole{n}{methods}\DUrole{p}{:} \DUrole{n}{list{[}collections.abc.Callable{[}{[}genetic.Chromosome{]}, \textasciitilde{} Genes{]}{]}}}, \emph{\DUrole{n}{methods\_rate}\DUrole{p}{:} \DUrole{n}{list\DUrole{p}{{[}}typing.Union\DUrole{p}{{[}}int\DUrole{p}{, }float\DUrole{p}{{]}}\DUrole{p}{{]}}}}}{}
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
A container for storing mutation functions and its rates. When called it receives a Chromosome and returns
a new Chromosome
This is supposed to receive functions which receives a Chromosome object and returns its genes with some random
modification
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
Mutated Chromosome

\item[{Return type}] \leavevmode
\sphinxAtStartPar
{\hyperref[\detokenize{genetic:genetic.Chromosome}]{\sphinxcrossref{Chromosome}}}

\end{description}\end{quote}

\sphinxAtStartPar
Initializes the Mutate object by receiving its parameters
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{methods}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{Callable}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}{\hyperref[\detokenize{genetic:genetic.Chromosome}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Chromosome}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{Genes}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Functions which receives a Chromosome object and returns a new genes

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{methods\_rate}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{numeric}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} The rate the functions tends be randomly chosen when the Mutate object is called. It must
have the same lenght as methods. Suppose methods is {[}m1, m2, m3{]} and methods\_rate is  {[}1, 2, 3{]}. m2 tends to
be chosen twice the m1 is and m3 thrice the m1 is

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{Strategies (class in genetic)@\spxentry{Strategies}\spxextra{class in genetic}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{genetic:genetic.Strategies}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{genetic.}}\sphinxbfcode{\sphinxupquote{Strategies}}}{\emph{\DUrole{n}{strategies}\DUrole{p}{:} \DUrole{n}{Tuple\DUrole{p}{{[}}{\hyperref[\detokenize{genetic:genetic.Mutate}]{\sphinxcrossref{genetic.Mutate}}}\DUrole{p}{, }{\hyperref[\detokenize{genetic:genetic.Crossover}]{\sphinxcrossref{genetic.Crossover}}}\DUrole{p}{, }{\hyperref[\detokenize{genetic:genetic.Create}]{\sphinxcrossref{genetic.Create}}}\DUrole{p}{{]}}}}, \emph{\DUrole{n}{strategies\_rate}\DUrole{p}{:} \DUrole{n}{list\DUrole{p}{{[}}typing.Union\DUrole{p}{{[}}int\DUrole{p}{, }float\DUrole{p}{{]}}\DUrole{p}{{]}}}}}{}
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
A container for sotoring the candidate generation strategies (Create, Mutate and Crossover objects) and its rates
It must receive only one of each generation strategy (Create, Mutate and Crossover) object.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
New Chromosome object with the genes generated by the strategy randomly selected

\item[{Return type}] \leavevmode
\sphinxAtStartPar
{\hyperref[\detokenize{genetic:genetic.Chromosome}]{\sphinxcrossref{Chromosome}}}

\end{description}\end{quote}

\sphinxAtStartPar
Initializes the Strategies object by receiving its parameters
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{strategies}} (\sphinxstyleliteralemphasis{\sphinxupquote{Tuple}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}{\hyperref[\detokenize{genetic:genetic.Create}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Create}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}{\hyperref[\detokenize{genetic:genetic.Mutate}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Mutate}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}{\hyperref[\detokenize{genetic:genetic.Crossover}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Crossover}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} A list with Create, Mutate and Crossover objects

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{strategies\_rate}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{numeric}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} The rate the Mutate, Crossover and Create objects tends be randomly chosen when the
Strategies object is called. It must have the same lenght as methods. Suppose strategies is {[}s1, s2, s3{]} and
strategies\_rate is  {[}1, 2, 3{]}. s2 tends to be chosen twice the s1 is and s3 thrice the s1 is.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{mutate\_best() (in module genetic)@\spxentry{mutate\_best()}\spxextra{in module genetic}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{genetic:genetic.mutate_best}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{genetic.}}\sphinxbfcode{\sphinxupquote{mutate\_best}}}{\emph{\DUrole{n}{best\_candidate}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{genetic:genetic.Chromosome}]{\sphinxcrossref{genetic.Chromosome}}}}}}{{ $\rightarrow$ genetic.Genes}}
\sphinxAtStartPar
Creation function that receives the Chromosome of the best candidate and pass it to the Mutate object to return
the result
This function is actually a void, it exists only to be called by import and to be override by the actual mutate\_best
function
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{best\_candidate}} ({\hyperref[\detokenize{genetic:genetic.Chromosome}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Chromosome}}}}}) \textendash{} Best candidate

\item[{Returns}] \leavevmode
\sphinxAtStartPar
Mutated genes of the best candidate

\item[{Return type}] \leavevmode
\sphinxAtStartPar
genes

\end{description}\end{quote}

\end{fulllineitems}

\index{mutate\_first() (in module genetic)@\spxentry{mutate\_first()}\spxextra{in module genetic}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{genetic:genetic.mutate_first}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{genetic.}}\sphinxbfcode{\sphinxupquote{mutate\_first}}}{\emph{\DUrole{n}{first\_parent}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{genetic:genetic.Chromosome}]{\sphinxcrossref{genetic.Chromosome}}}}}}{{ $\rightarrow$ genetic.Genes}}
\sphinxAtStartPar
Creation function that receives the Chromosome of the first created parent and pass it to the Mutate object to
return the result
This function is actually a void, it exists only to be called by import and to be override by the actual
mutate\_first function
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{first\_parent}} ({\hyperref[\detokenize{genetic:genetic.Chromosome}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Chromosome}}}}}) \textendash{} First created candidate

\item[{Returns}] \leavevmode
\sphinxAtStartPar
Mutated genes of the first candidate

\item[{Return type}] \leavevmode
\sphinxAtStartPar
genes

\end{description}\end{quote}

\end{fulllineitems}



\section{molecular module}
\label{\detokenize{molecular:module-molecular}}\label{\detokenize{molecular:molecular-module}}\label{\detokenize{molecular::doc}}\index{module@\spxentry{module}!molecular@\spxentry{molecular}}\index{molecular@\spxentry{molecular}!module@\spxentry{module}}\index{Molecule (class in molecular)@\spxentry{Molecule}\spxextra{class in molecular}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{molecular:molecular.Molecule}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{molecular.}}\sphinxbfcode{\sphinxupquote{Molecule}}}{\emph{\DUrole{n}{basis}\DUrole{p}{:} \DUrole{n}{str}}, \emph{\DUrole{n}{geometry}\DUrole{p}{:} \DUrole{n}{list\DUrole{p}{{[}}list\DUrole{p}{{[}}typing.Union\DUrole{p}{{[}}str\DUrole{p}{, }int\DUrole{p}{, }float\DUrole{p}{{]}}\DUrole{p}{{]}}\DUrole{p}{{]}}}}, \emph{\DUrole{n}{settings}\DUrole{p}{:} \DUrole{n}{list\DUrole{p}{{[}}str\DUrole{p}{{]}}}}, \emph{\DUrole{n}{parameters}\DUrole{p}{:} \DUrole{n}{dict\DUrole{p}{{[}}str\DUrole{p}{, }typing.Union\DUrole{p}{{[}}int\DUrole{p}{, }float\DUrole{p}{{]}}\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{\{\}}}, \emph{\DUrole{n}{rand\_range}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}Tuple\DUrole{p}{{[}}Union\DUrole{p}{{[}}int\DUrole{p}{, }float\DUrole{p}{{]}}\DUrole{p}{, }Union\DUrole{p}{{[}}int\DUrole{p}{, }float\DUrole{p}{{]}}\DUrole{p}{{]}}\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{label}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}str\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{output}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}str\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{output\_values}\DUrole{p}{:} \DUrole{n}{dict\DUrole{p}{{[}}str\DUrole{p}{, }typing.Union\DUrole{p}{{[}}int\DUrole{p}{, }float\DUrole{p}{{]}}\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{\{\}}}, \emph{\DUrole{n}{was\_optg}\DUrole{p}{:} \DUrole{n}{bool} \DUrole{o}{=} \DUrole{default_value}{False}}}{}
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
Molecular geometry compatible with Molpro
This class provides a framework for storing molecular geometry, generating Molpro inputs and store output
information. It also brings functions to work with genetic algorithm.

\sphinxAtStartPar
Initializes the Molecule object by receiving its parameters
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{basis}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Hilbert space basis

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{geometry}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Z\sphinxhyphen{}matrix input

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{settings}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Molpro calculation settings

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{parameters}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{numeric}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} The values of geometry variables, defaults to dict()

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{rand\_range}} (\sphinxstyleliteralemphasis{\sphinxupquote{Tuple}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{numeric}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{numeric}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Min and max values that can be generated when distances are mutated, defaults to None

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{label}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} A tag which can be used to identify the Molecule object, defaults to None

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{output}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} The address of the molecule’s .out document generated by Molpro, defaults to None

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{output\_values}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{numeric}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Values extracted from the output document, defaults to dict()

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{was\_optg}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} True if the geometry was already optmized with optg, false if it doesn’t

\end{itemize}

\end{description}\end{quote}
\index{copy() (molecular.Molecule method)@\spxentry{copy()}\spxextra{molecular.Molecule method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{molecular:molecular.Molecule.copy}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{copy}}}{}{{ $\rightarrow$ {\hyperref[\detokenize{molecular:molecular.Molecule}]{\sphinxcrossref{molecular.Molecule}}}}}
\sphinxAtStartPar
Returns a totally independent copy of itself
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
Copy of self

\item[{Return type}] \leavevmode
\sphinxAtStartPar
{\hyperref[\detokenize{molecular:molecular.Molecule}]{\sphinxcrossref{Molecule}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{dist\_unit (molecular.Molecule property)@\spxentry{dist\_unit}\spxextra{molecular.Molecule property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{molecular:molecular.Molecule.dist_unit}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{dist\_unit}}\sphinxbfcode{\sphinxupquote{: str}}}
\sphinxAtStartPar
Gets the distance unit used to describe the molecule
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
Distance unit

\item[{Return type}] \leavevmode
\sphinxAtStartPar
str

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_value() (molecular.Molecule method)@\spxentry{get\_value()}\spxextra{molecular.Molecule method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{molecular:molecular.Molecule.get_value}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_value}}}{\emph{\DUrole{n}{wanted}\DUrole{p}{:} \DUrole{n}{list\DUrole{p}{{[}}str\DUrole{p}{{]}}}}, \emph{\DUrole{n}{document}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}str\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{directory}\DUrole{p}{:} \DUrole{n}{str} \DUrole{o}{=} \DUrole{default_value}{\textquotesingle{}data\textquotesingle{}}}, \emph{\DUrole{n}{keep\_output}\DUrole{p}{:} \DUrole{n}{bool} \DUrole{o}{=} \DUrole{default_value}{False}}, \emph{\DUrole{n}{nthreads}\DUrole{p}{:} \DUrole{n}{int} \DUrole{o}{=} \DUrole{default_value}{1}}, \emph{\DUrole{n}{update\_self}\DUrole{p}{:} \DUrole{n}{bool} \DUrole{o}{=} \DUrole{default_value}{True}}}{{ $\rightarrow$ dict\DUrole{p}{{[}}str\DUrole{p}{, }float\DUrole{p}{{]}}}}
\sphinxAtStartPar
Reads the Molpro’s output file and return the wanted values.
Reads the Molpro’s output file, searchs for wanted strings and gets the numeric value that is in the same row
then returns a dictionary where the keys are the wanted strings and the values are the numeric strings
correspondents. If document.out already exists in /directory the document will be read and the values returned.
If it doesn’t and document.inp already exists in directory, it will execute Molpro over the input. If neither
document.out nor document.inp exists, document.inp will be created and Molpro executed over it and after
document.inp will be deleted
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{wanted}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} list of variables to be search in the output. They must be the string which precedes the wanted
numeric value in molpro’s output

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{document}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Documents’ name, defaults to None

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{directory}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Directory adress where the input and the output will be relative to \_\_main\_\_, defaults to
‘data’

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{keep\_output}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} If it’s True, the output will be kept and its name will be put in self.output, else it will
be deleted after is read. defaults to False

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{nthreads}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Number of threads useds in Molpro calculation, defaults to 1

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{update\_self}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} If it’s True, self.output\_values will be updated with each item of wanted. If it’s False,
self.output\_values will not be updated, and the output values will can only be accessed by the returned dict

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
Wanted strings and correspondent values

\item[{Return type}] \leavevmode
\sphinxAtStartPar
dict{[}str, float{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{load() (molecular.Molecule static method)@\spxentry{load()}\spxextra{molecular.Molecule static method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{molecular:molecular.Molecule.load}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxbfcode{\sphinxupquote{load}}}{\emph{\DUrole{n}{file}\DUrole{p}{:} \DUrole{n}{str}}, \emph{\DUrole{n}{rand\_range}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}Tuple\DUrole{p}{{[}}Union\DUrole{p}{{[}}int\DUrole{p}{, }float\DUrole{p}{{]}}\DUrole{p}{, }Union\DUrole{p}{{[}}int\DUrole{p}{, }float\DUrole{p}{{]}}\DUrole{p}{{]}}\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{label}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}str\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{output}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}str\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{output\_values}\DUrole{p}{:} \DUrole{n}{dict\DUrole{p}{{[}}str\DUrole{p}{, }typing.Union\DUrole{p}{{[}}int\DUrole{p}{, }float\DUrole{p}{{]}}\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{\{\}}}, \emph{\DUrole{n}{was\_optg}\DUrole{p}{:} \DUrole{n}{bool} \DUrole{o}{=} \DUrole{default_value}{False}}}{{ $\rightarrow$ {\hyperref[\detokenize{molecular:molecular.Molecule}]{\sphinxcrossref{molecular.Molecule}}}}}
\sphinxAtStartPar
Loads a molecule from a .inp document and returns its Molecule object
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{file}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} File name, it must end with .inp but the .inp may not be included here

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{rand\_range}} (\sphinxstyleliteralemphasis{\sphinxupquote{Tuple}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{numeric}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{numeric}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Min and max values that can be generated when distances are mutated, defaults to None

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{label}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} A tag which can be used to identify the object, defaults to None

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{output}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} The address of the molecule’s .out document generated by Molpro, defaults to None

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{output\_values}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{numeric}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Values extracted from the output document, defaults to dict()

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{was\_optg}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} True if the geometry was already optmized with optg, false if it doesn’t

\end{itemize}

\item[{Raises}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{Exception}} \textendash{} Invalid Z\sphinxhyphen{}matrix

\item[{Returns}] \leavevmode
\sphinxAtStartPar
Loaded molecule

\item[{Return type}] \leavevmode
\sphinxAtStartPar
{\hyperref[\detokenize{molecular:molecular.Molecule}]{\sphinxcrossref{Molecule}}}

\end{description}\end{quote}

\sphinxAtStartPar
The file must have the one of the following structures:

\sphinxAtStartPar
{\color{red}\bfseries{}**}{\color{red}\bfseries{}*},

\sphinxAtStartPar
basis=\{
!
! aluminium            (6s,4p) \sphinxhyphen{}\textgreater{} {[}3s,2p{]}
s, AL , 0.5605994123E+00, 0.1923360636E+00, 0.7304329554E+01, 0.1852570854E+01, 0.1343774607E+03, 0.2391912027E+02
c, 1.2, \sphinxhyphen{}0.2983986045E+00, 0.1227982887E+01
c, 3.4, 0.4947176920E\sphinxhyphen{}01, 0.9637824081E+00
c, 5.6, 0.4301284983E+00, 0.6789135305E+00
p, AL , 0.7304329554E+01, 0.1852570854E+01, 0.5605994123E+00, 0.1923360636E+00
c, 1.2, 0.5115407076E+00, 0.6128198961E+00
c, 3.4, 0.3480471912E+00, 0.7222523221E+00
\}

\sphinxAtStartPar
r1=2.706
r2=2.414
r3=2.481
r4=2.817
r5=2.529
r6=2.547
r7=2.510
r8=2.401
r9=2.666
t1=66.357
t2=65.256
t3=115.675
t4=107.280
t5=105.113
t6=97.637
t7=104.449
t8=63.620
a1=104.0
a2=89.4
a3=345.8
a4=272.6
a5=43.5
a6=341.2
a7=238.2

\sphinxAtStartPar
geometry=\{ang
Al
Al,  1,     r1
Al,  2,     r2 ,    1,      t1
Al,  2,     r3 ,    1,     t2,       3,    a1
Al,  3,     r4 ,    2,     t3,       1,     a2
Al,  1,     r5 ,    2,     t4,       3,    a3
Al,  5,     r6 ,    3,     t5,       2,    a4
Al,  7,     r7,     5,      t6,      3,     a5
Al,  5,     r8,     3,      t7,      2,    a6
Al,  4,     r9,     2,      t8,      1,     a7
\}

\sphinxAtStartPar
SET,CHARGE=0
direct
\{ks, b3lyp,maxit=200\}

\sphinxAtStartPar
—

\sphinxAtStartPar
or

\sphinxAtStartPar
{\color{red}\bfseries{}**}{\color{red}\bfseries{}*},

\sphinxAtStartPar
basis=\{
!
! aluminium            (6s,4p) \sphinxhyphen{}\textgreater{} {[}3s,2p{]}
s, AL , 0.5605994123E+00, 0.1923360636E+00, 0.7304329554E+01, 0.1852570854E+01, 0.1343774607E+03, 0.2391912027E+02
c, 1.2, \sphinxhyphen{}0.2983986045E+00, 0.1227982887E+01
c, 3.4, 0.4947176920E\sphinxhyphen{}01, 0.9637824081E+00
c, 5.6, 0.4301284983E+00, 0.6789135305E+00
p, AL , 0.7304329554E+01, 0.1852570854E+01, 0.5605994123E+00, 0.1923360636E+00
c, 1.2, 0.5115407076E+00, 0.6128198961E+00
c, 3.4, 0.3480471912E+00, 0.7222523221E+00
\}

\sphinxAtStartPar
geometry=\{ang
Al
Al,  1,     2.706
Al,  2,     2.414,     1,      66.357
Al,  2,     2.481,     1,      65.256,       3,     104.0
Al,  3,     2.817,     2,      115.675,      1,     89.4
Al,  1,     2.529,     2,      107.280,      3,     345.8
Al,  5,     2.547,     3,      105.113,      2,     272.6
Al,  7,     2.510,     5,      97.637,       3,     43.5
Al,  5,     2.401,     3,      104.449,      2,     341.2
Al,  4,     2.666,     2,      63.620,       1,     238.2
\}

\sphinxAtStartPar
SET,CHARGE=0
direct
\{ks, b3lyp,maxit=200\}

\sphinxAtStartPar
—

\sphinxAtStartPar
Respecting empty lines between different sections of the file. That is, it must have one empty line between each
section of the file. Here we can see we can have until six sections in the file: the beggining’s section or just
‘{\color{red}\bfseries{}**}{\color{red}\bfseries{}*},’, the basis’ section, the parameters’ section (that can exists or don’t), the geometry’s section, the
settings’ section and the end section or just ‘—’

\end{fulllineitems}

\index{mutate\_angles() (molecular.Molecule method)@\spxentry{mutate\_angles()}\spxextra{molecular.Molecule method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{molecular:molecular.Molecule.mutate_angles}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{mutate\_angles}}}{\emph{\DUrole{n}{times}\DUrole{p}{:} \DUrole{n}{int} \DUrole{o}{=} \DUrole{default_value}{1}}}{{ $\rightarrow$ {\hyperref[\detokenize{molecular:molecular.Molecule}]{\sphinxcrossref{molecular.Molecule}}}}}
\sphinxAtStartPar
Provokes a mutation in some random angle parameter
Selects a random angle parameter from the geometry and assign it a random value between 0 and
360 degrees. This process is repeated an amount of times equal to times
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{times}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Number of mutations, defaults to 1

\item[{Returns}] \leavevmode
\sphinxAtStartPar
Itself mutated

\item[{Return type}] \leavevmode
\sphinxAtStartPar
{\hyperref[\detokenize{molecular:molecular.Molecule}]{\sphinxcrossref{Molecule}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{mutate\_distances() (molecular.Molecule method)@\spxentry{mutate\_distances()}\spxextra{molecular.Molecule method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{molecular:molecular.Molecule.mutate_distances}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{mutate\_distances}}}{\emph{\DUrole{n}{times}\DUrole{p}{:} \DUrole{n}{int} \DUrole{o}{=} \DUrole{default_value}{1}}}{{ $\rightarrow$ {\hyperref[\detokenize{molecular:molecular.Molecule}]{\sphinxcrossref{molecular.Molecule}}}}}
\sphinxAtStartPar
Provokes a mutation in some random distance parameter
Selects a random distance parameter from the geometry and assign it a random value in the range gave by
self.rand\_range. This process is repeated a number of times equal to times
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{times}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of mutations, defaults to 1

\item[{Returns}] \leavevmode
\sphinxAtStartPar
Itself mutated

\item[{Return type}] \leavevmode
\sphinxAtStartPar
{\hyperref[\detokenize{molecular:molecular.Molecule}]{\sphinxcrossref{Molecule}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{optg() (molecular.Molecule method)@\spxentry{optg()}\spxextra{molecular.Molecule method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{molecular:molecular.Molecule.optg}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{optg}}}{\emph{\DUrole{n}{wanted}\DUrole{p}{:} \DUrole{n}{list\DUrole{p}{{[}}str\DUrole{p}{{]}}}}, \emph{\DUrole{n}{directory}\DUrole{p}{:} \DUrole{n}{str} \DUrole{o}{=} \DUrole{default_value}{\textquotesingle{}data\textquotesingle{}}}, \emph{\DUrole{n}{nthreads}\DUrole{p}{:} \DUrole{n}{int} \DUrole{o}{=} \DUrole{default_value}{1}}, \emph{\DUrole{n}{keep\_output}\DUrole{o}{=}\DUrole{default_value}{False}}}{{ $\rightarrow$ {\hyperref[\detokenize{molecular:molecular.Molecule}]{\sphinxcrossref{molecular.Molecule}}}}}
\sphinxAtStartPar
Turns the molecule in its own geometric optimized version
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{wanted}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} list of variables to be search in the output

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{directory}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Directory adress where the input and the output will be relative to \_\_main\_\_, defaults to
‘data’

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{nthreads}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Number of threads useds in Molpro calculation, defaults to 1

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{keep\_output}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} If it’s True, the output will be kept, else it will be deleted after be read.
defaults to False

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
Itself optmized version

\item[{Return type}] \leavevmode
\sphinxAtStartPar
{\hyperref[\detokenize{molecular:molecular.Molecule}]{\sphinxcrossref{Molecule}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{save() (molecular.Molecule method)@\spxentry{save()}\spxextra{molecular.Molecule method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{molecular:molecular.Molecule.save}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{save}}}{\emph{\DUrole{n}{document}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}str\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{directory}\DUrole{p}{:} \DUrole{n}{str} \DUrole{o}{=} \DUrole{default_value}{\textquotesingle{}data\textquotesingle{}}}}{{ $\rightarrow$ None}}
\sphinxAtStartPar
Saves the object data in a .inp document
Saves the object data in document.inp. If document receives None it’ll be the molecule’s label, if it still
None it will be str(self.\_\_hash\_\_()). If the directory didn’t exist it wil be created
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{document}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Document’s name, defaults to None

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{directory}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Directory where the document will be saved, defaults to ‘data’

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{swap\_mutate() (molecular.Molecule method)@\spxentry{swap\_mutate()}\spxextra{molecular.Molecule method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{molecular:molecular.Molecule.swap_mutate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{swap\_mutate}}}{}{{ $\rightarrow$ {\hyperref[\detokenize{molecular:molecular.Molecule}]{\sphinxcrossref{molecular.Molecule}}}}}
\sphinxAtStartPar
Provokes a swap mutation in itsef
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
Itself mutated

\item[{Return type}] \leavevmode
\sphinxAtStartPar
{\hyperref[\detokenize{molecular:molecular.Molecule}]{\sphinxcrossref{Molecule}}}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{crossover\_1() (in module molecular)@\spxentry{crossover\_1()}\spxextra{in module molecular}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{molecular:molecular.crossover_1}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{molecular.}}\sphinxbfcode{\sphinxupquote{crossover\_1}}}{\emph{\DUrole{n}{parent}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{molecular:molecular.Molecule}]{\sphinxcrossref{molecular.Molecule}}}}}, \emph{\DUrole{n}{donor}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{molecular:molecular.Molecule}]{\sphinxcrossref{molecular.Molecule}}}}}, \emph{\DUrole{n}{label}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}str\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}}{{ $\rightarrow$ {\hyperref[\detokenize{molecular:molecular.Molecule}]{\sphinxcrossref{molecular.Molecule}}}}}
\sphinxAtStartPar
Produces a new molecule with the crossover of parent and donor molecules by cutting each one in one point and
combining the resultant pieces
Creates a copy of the parent molecule then randomly choices a row and a ‘column’ from the geometry and there divides
the geometry in two pieces. Then randomly pick one of these pieces and attach with the complementar part provided by
the donor molecule generating the geometry of the child molecule
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{parent}} ({\hyperref[\detokenize{molecular:molecular.Molecule}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Molecule}}}}}) \textendash{} Parent molecule

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{donor}} ({\hyperref[\detokenize{molecular:molecular.Molecule}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Molecule}}}}}) \textendash{} Donor molecule

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{label}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} A tag which can be used to identify the child molecule, defaults to None

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
Child molecule

\item[{Return type}] \leavevmode
\sphinxAtStartPar
{\hyperref[\detokenize{molecular:molecular.Molecule}]{\sphinxcrossref{Molecule}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{crossover\_2() (in module molecular)@\spxentry{crossover\_2()}\spxextra{in module molecular}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{molecular:molecular.crossover_2}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{molecular.}}\sphinxbfcode{\sphinxupquote{crossover\_2}}}{\emph{\DUrole{n}{parent}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{molecular:molecular.Molecule}]{\sphinxcrossref{molecular.Molecule}}}}}, \emph{\DUrole{n}{donor}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{molecular:molecular.Molecule}]{\sphinxcrossref{molecular.Molecule}}}}}, \emph{\DUrole{n}{label}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}str\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}}{{ $\rightarrow$ {\hyperref[\detokenize{molecular:molecular.Molecule}]{\sphinxcrossref{molecular.Molecule}}}}}
\sphinxAtStartPar
Produces a new molecule with the crossover of parent and donor molecules by cutting each one in two points and
combining the resultant pieces
Randomly cuts the parent molecule’s geometry in two points. The sequence between these two points will either
replace its correspondent in the donor molecule’s geometry or be replaced by it (randomly) generating the geometry
of the child molecule that will be returned. At leas four atoms are needed to realize this process. Trying it with
molecules smaller than it will raise an exception
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{parent}} ({\hyperref[\detokenize{molecular:molecular.Molecule}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Molecule}}}}}) \textendash{} Parent molecule

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{donor}} ({\hyperref[\detokenize{molecular:molecular.Molecule}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Molecule}}}}}) \textendash{} Donor molecule

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{label}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} A tag which can be used to identify the child molecule, defaults to None

\end{itemize}

\item[{Raises}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{Exception}} \textendash{} At least 4 atoms are needed to perform crossover\_2

\item[{Returns}] \leavevmode
\sphinxAtStartPar
child Molecule

\item[{Return type}] \leavevmode
\sphinxAtStartPar
{\hyperref[\detokenize{molecular:molecular.Molecule}]{\sphinxcrossref{Molecule}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{crossover\_n() (in module molecular)@\spxentry{crossover\_n()}\spxextra{in module molecular}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{molecular:molecular.crossover_n}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{molecular.}}\sphinxbfcode{\sphinxupquote{crossover\_n}}}{\emph{\DUrole{n}{parent}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{molecular:molecular.Molecule}]{\sphinxcrossref{molecular.Molecule}}}}}, \emph{\DUrole{n}{donor}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{molecular:molecular.Molecule}]{\sphinxcrossref{molecular.Molecule}}}}}, \emph{\DUrole{n}{label}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}str\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}}{{ $\rightarrow$ {\hyperref[\detokenize{molecular:molecular.Molecule}]{\sphinxcrossref{molecular.Molecule}}}}}
\sphinxAtStartPar
Returns a new molecule which randomly carries parameters from the parent and donor molecules
Creates a copy of the parent molecule, randomly choices an amount of parameters the minimun being one and the
maximun being the total amount of parameters minus one. Then randomly choices this amount of parameters from the
donor molecule to replace the respectives parameters the child molecule inherited from parent molecule
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{parent}} ({\hyperref[\detokenize{molecular:molecular.Molecule}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Molecule}}}}}) \textendash{} Parent molecule

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{donor}} ({\hyperref[\detokenize{molecular:molecular.Molecule}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Molecule}}}}}) \textendash{} Donor molecule

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{label}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} A tag which can be used to identify the child molecule, defaults to None

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
Child molecule

\item[{Return type}] \leavevmode
\sphinxAtStartPar
{\hyperref[\detokenize{molecular:molecular.Molecule}]{\sphinxcrossref{Molecule}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{mutate\_angles() (in module molecular)@\spxentry{mutate\_angles()}\spxextra{in module molecular}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{molecular:molecular.mutate_angles}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{molecular.}}\sphinxbfcode{\sphinxupquote{mutate\_angles}}}{\emph{\DUrole{n}{molecule}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{molecular:molecular.Molecule}]{\sphinxcrossref{molecular.Molecule}}}}}, \emph{\DUrole{n}{times}\DUrole{p}{:} \DUrole{n}{int} \DUrole{o}{=} \DUrole{default_value}{1}}, \emph{\DUrole{n}{label}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}str\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}}{{ $\rightarrow$ {\hyperref[\detokenize{molecular:molecular.Molecule}]{\sphinxcrossref{molecular.Molecule}}}}}
\sphinxAtStartPar
Returns a molecule’s copy with some random angle parameter randomized between 0 and 360 degrees
Creates a moecule’s copy and randomly choices an angle parameter and set it value to a random value between 0 and
360. The amount of mutations performed is equal times
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{molecule}} ({\hyperref[\detokenize{molecular:molecular.Molecule}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Molecule}}}}}) \textendash{} Original molecule

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{times}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Amount of angle mutations, defaults to 1

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{label}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Label of the new molecule, defaults to None

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
New molecule

\item[{Return type}] \leavevmode
\sphinxAtStartPar
{\hyperref[\detokenize{molecular:molecular.Molecule}]{\sphinxcrossref{Molecule}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{mutate\_distances() (in module molecular)@\spxentry{mutate\_distances()}\spxextra{in module molecular}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{molecular:molecular.mutate_distances}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{molecular.}}\sphinxbfcode{\sphinxupquote{mutate\_distances}}}{\emph{\DUrole{n}{molecule}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{molecular:molecular.Molecule}]{\sphinxcrossref{molecular.Molecule}}}}}, \emph{\DUrole{n}{times}\DUrole{p}{:} \DUrole{n}{int} \DUrole{o}{=} \DUrole{default_value}{1}}, \emph{\DUrole{n}{label}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}str\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}}{{ $\rightarrow$ {\hyperref[\detokenize{molecular:molecular.Molecule}]{\sphinxcrossref{molecular.Molecule}}}}}
\sphinxAtStartPar
Returns a molecule’s copy with some random distance parameter randomized in the range gave by rand\_range
Creates a moecule’s copy and randomly choices a distance parameter and set it value to a random value between 0 and
self.rand\_range. The amount of mutations performed is equal times
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{molecule}} ({\hyperref[\detokenize{molecular:molecular.Molecule}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Molecule}}}}}) \textendash{} Original molecule

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{times}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Amount of angle mutations, defaults to 1

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{label}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Label of the new molecule, defaults to None

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
New molecule

\item[{Return type}] \leavevmode
\sphinxAtStartPar
{\hyperref[\detokenize{molecular:molecular.Molecule}]{\sphinxcrossref{Molecule}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{optg() (in module molecular)@\spxentry{optg()}\spxextra{in module molecular}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{molecular:molecular.optg}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{molecular.}}\sphinxbfcode{\sphinxupquote{optg}}}{\emph{\DUrole{n}{molecule}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{molecular:molecular.Molecule}]{\sphinxcrossref{molecular.Molecule}}}}}, \emph{\DUrole{n}{wanted\_energy}\DUrole{p}{:} \DUrole{n}{str}}, \emph{\DUrole{n}{directory}\DUrole{p}{:} \DUrole{n}{str} \DUrole{o}{=} \DUrole{default_value}{\textquotesingle{}data\textquotesingle{}}}, \emph{\DUrole{n}{nthreads}\DUrole{p}{:} \DUrole{n}{int} \DUrole{o}{=} \DUrole{default_value}{1}}, \emph{\DUrole{n}{keep\_output}\DUrole{p}{:} \DUrole{n}{bool} \DUrole{o}{=} \DUrole{default_value}{False}}}{{ $\rightarrow$ {\hyperref[\detokenize{molecular:molecular.Molecule}]{\sphinxcrossref{molecular.Molecule}}}}}
\sphinxAtStartPar
Executes geometric optimization over the molecule using Molpro and returns a new molecule with the optimized
geometry
Creates a copy of the original molecule, appends ‘optg’ in the settings if it’s not already there and calls the
get\_value function with it. Then updates the wanted\_energy in optmized\_molecule.output\_values and updates all angles
and distances parameters in {[}optmized\_molecule.parameters{]}. To use this function there cannont be any literal value
in the molecule’s geometry, all values must be as variables names in geometry and has its literal values declared in
molecule.parameters
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{molecule}} ({\hyperref[\detokenize{molecular:molecular.Molecule}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Molecule}}}}}) \textendash{} Original molecule

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{wanted\_energy}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} The key wanted for the energy in optimized\_molecule.output\_values

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{directory}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Directory adress where the input and the output will be relative to \_\_main\_\_, defaults to ‘data’

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{nthreads}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Number of threads useds in Molpro calculation, defaults to 1

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{keep\_output}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} If it’s True, the output will be kept and its name will be put in self.output, else it will be
deleted after is read. defaults to False

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
Optmized molecule

\item[{Return type}] \leavevmode
\sphinxAtStartPar
{\hyperref[\detokenize{molecular:molecular.Molecule}]{\sphinxcrossref{Molecule}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{random\_molecule() (in module molecular)@\spxentry{random\_molecule()}\spxextra{in module molecular}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{molecular:molecular.random_molecule}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{molecular.}}\sphinxbfcode{\sphinxupquote{random\_molecule}}}{\emph{\DUrole{n}{molecular\_formula}\DUrole{p}{:} \DUrole{n}{str}}, \emph{\DUrole{n}{basis}\DUrole{p}{:} \DUrole{n}{str}}, \emph{\DUrole{n}{settings}\DUrole{p}{:} \DUrole{n}{list\DUrole{p}{{[}}str\DUrole{p}{{]}}}}, \emph{\DUrole{n}{rand\_range}\DUrole{p}{:} \DUrole{n}{Tuple\DUrole{p}{{[}}Union\DUrole{p}{{[}}int\DUrole{p}{, }float\DUrole{p}{{]}}\DUrole{p}{, }Union\DUrole{p}{{[}}int\DUrole{p}{, }float\DUrole{p}{{]}}\DUrole{p}{{]}}}}, \emph{\DUrole{n}{label}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}str\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{dist\_unit}\DUrole{p}{:} \DUrole{n}{str} \DUrole{o}{=} \DUrole{default_value}{\textquotesingle{}ang\textquotesingle{}}}}{{ $\rightarrow$ {\hyperref[\detokenize{molecular:molecular.Molecule}]{\sphinxcrossref{molecular.Molecule}}}}}
\sphinxAtStartPar
Creates molecule with a entirely random geometry given the molecular formula
Creates a geometry with all distances parameters randomized in the range gave by rand\_range and all angles
randomized between 0 and 360 given the molecular formula which is a string containing the elements followed by its
amount like’H2O’, ‘C6H12O6’, ‘Al10’… It doesn’t support parenthesys and is invariant to the order of elements.
What matters in molecular\_formula is which number follows which element
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{molecular\_formula}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} The molecular formula of the wanted molecule

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{basis}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Hilbert space basis

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{settings}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Molpro calculation settings

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{rand\_range}} (\sphinxstyleliteralemphasis{\sphinxupquote{Tuple}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{numeric}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{numeric}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Min and max values that can be generated when distances are mutated

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{label}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} A tag which can be used to identify the molecule, defaults to None

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{dist\_unit}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Distance unit, defaults to ‘ang’

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
Random molecule

\item[{Return type}] \leavevmode
\sphinxAtStartPar
{\hyperref[\detokenize{molecular:molecular.Molecule}]{\sphinxcrossref{Molecule}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{randomize() (in module molecular)@\spxentry{randomize()}\spxextra{in module molecular}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{molecular:molecular.randomize}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{molecular.}}\sphinxbfcode{\sphinxupquote{randomize}}}{\emph{\DUrole{n}{molecule}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{molecular:molecular.Molecule}]{\sphinxcrossref{molecular.Molecule}}}}}, \emph{\DUrole{n}{label}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}str\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}}{{ $\rightarrow$ {\hyperref[\detokenize{molecular:molecular.Molecule}]{\sphinxcrossref{molecular.Molecule}}}}}
\sphinxAtStartPar
Returns a molecule’s copy with all distances and angles parameters randomized
Creates a molecule’s copy and replace all distance parameters with random values in the range gave by
molecule.rand\_range and replace all angle parameters with random values between 0 and 360
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{molecule}} ({\hyperref[\detokenize{molecular:molecular.Molecule}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Molecule}}}}}) \textendash{} Original molecule

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{label}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} A tag which can be used to identify the new molecule, defaults to None

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
New molecule

\item[{Return type}] \leavevmode
\sphinxAtStartPar
{\hyperref[\detokenize{molecular:molecular.Molecule}]{\sphinxcrossref{Molecule}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{swap\_mutate() (in module molecular)@\spxentry{swap\_mutate()}\spxextra{in module molecular}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{molecular:molecular.swap_mutate}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{molecular.}}\sphinxbfcode{\sphinxupquote{swap\_mutate}}}{\emph{\DUrole{n}{molecule}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{molecular:molecular.Molecule}]{\sphinxcrossref{molecular.Molecule}}}}}, \emph{\DUrole{n}{times}\DUrole{p}{:} \DUrole{n}{int} \DUrole{o}{=} \DUrole{default_value}{1}}, \emph{\DUrole{n}{label}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}str\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}}{{ $\rightarrow$ {\hyperref[\detokenize{molecular:molecular.Molecule}]{\sphinxcrossref{molecular.Molecule}}}}}
\sphinxAtStartPar
Returns a molecule’s copy with randomly swapped places parameters
Creates a molecule’s copy and randomly swap parameters of its places. It makes a amount of random swaps equal
times.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{molecule}} ({\hyperref[\detokenize{molecular:molecular.Molecule}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Molecule}}}}}) \textendash{} Original molecule

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{times}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Number of random swaps, defaults to 1

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{label}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Label of the new molecule, defaults to None

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
New molecule

\item[{Return type}] \leavevmode
\sphinxAtStartPar
{\hyperref[\detokenize{molecular:molecular.Molecule}]{\sphinxcrossref{Molecule}}}

\end{description}\end{quote}

\end{fulllineitems}



\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\let\bigletter\sphinxstyleindexlettergroup
\bigletter{g}
\item\relax\sphinxstyleindexentry{genetic}\sphinxstyleindexpageref{genetic:\detokenize{module-genetic}}
\indexspace
\bigletter{m}
\item\relax\sphinxstyleindexentry{molecular}\sphinxstyleindexpageref{molecular:\detokenize{module-molecular}}
\item\relax\sphinxstyleindexentry{MolOpt}\sphinxstyleindexpageref{MolOpt:\detokenize{module-MolOpt}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}
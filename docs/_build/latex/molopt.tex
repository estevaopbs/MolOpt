%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsible pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{tgtermes}
\usepackage{tgheros}
\renewcommand{\ttdefault}{txtt}



\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=auto}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\contentsname}{Contents:}}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{1}



\title{MolOpt}
\date{Nov 06, 2021}
\release{}
\author{Estevão Santos}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}



\chapter{MolOpt}
\label{\detokenize{modules:molopt}}\label{\detokenize{modules::doc}}

\section{MolOpt package}
\label{\detokenize{MolOpt:molopt-package}}\label{\detokenize{MolOpt::doc}}

\subsection{genetic subpackage}
\label{\detokenize{MolOpt.genetic:module-MolOpt.genetic.genetic}}\label{\detokenize{MolOpt.genetic:genetic-subpackage}}\label{\detokenize{MolOpt.genetic::doc}}\index{module@\spxentry{module}!MolOpt.genetic.genetic@\spxentry{MolOpt.genetic.genetic}}\index{MolOpt.genetic.genetic@\spxentry{MolOpt.genetic.genetic}!module@\spxentry{module}}\index{Chromosome (class in MolOpt.genetic.genetic)@\spxentry{Chromosome}\spxextra{class in MolOpt.genetic.genetic}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MolOpt.genetic:MolOpt.genetic.genetic.Chromosome}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{Chromosome}}}{\emph{\DUrole{n}{genes}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}Any\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{fitness}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}Any\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{strategy}\DUrole{p}{:} \DUrole{n}{list{[}collections.abc.Callable{[}{[}\textasciitilde{} Chromosome{]}, \textasciitilde{} Genes{]}{]}} \DUrole{o}{=} \DUrole{default_value}{{[}{]}}}, \emph{\DUrole{n}{age}\DUrole{p}{:} \DUrole{n}{int} \DUrole{o}{=} \DUrole{default_value}{0}}, \emph{\DUrole{n}{lineage}\DUrole{p}{:} \DUrole{n}{list} \DUrole{o}{=} \DUrole{default_value}{{[}{]}}}, \emph{\DUrole{n}{label}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}str\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}}{}
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
Object that represents the candidates.
\index{strategy\_str (Chromosome property)@\spxentry{strategy\_str}\spxextra{Chromosome property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MolOpt.genetic:MolOpt.genetic.genetic.Chromosome.strategy_str}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{strategy\_str}}\sphinxbfcode{\sphinxupquote{: str}}}
\sphinxAtStartPar
Returns a string which represents the list of the functions used to obtain the current Chromosome object
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
String of a list of the names of the functions used to obtain the current Chromosome object

\item[{Return type}] \leavevmode
\sphinxAtStartPar
str

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{Create (class in MolOpt.genetic.genetic)@\spxentry{Create}\spxextra{class in MolOpt.genetic.genetic}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MolOpt.genetic:MolOpt.genetic.genetic.Create}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{Create}}}{\emph{\DUrole{n}{methods}\DUrole{p}{:} \DUrole{n}{list{[}collections.abc.Callable{[}{[}MolOpt.genetic.genetic.Chromosome{]}, \textasciitilde{} Genes{]}{]}}}, \emph{\DUrole{n}{methods\_rate}\DUrole{p}{:} \DUrole{n}{list\DUrole{p}{{[}}typing.Union\DUrole{p}{{[}}int\DUrole{p}{, }float\DUrole{p}{{]}}\DUrole{p}{{]}}}}}{}
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
A container for storing genes creation functions and its rates. When called it receives the first\_parent 
Chromosome and returns a new Chromosome. This class is supposed to receive functions which receive a generic parent 
Chromosome and return a whole new genes without any bound to the parent’s one. The exceptions are mutate\_best and 
mutate\_first, which respectively returns the result of passing the best and the first parent, respectively, to the 
mutate object
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
New Chromosome object with the created genes

\item[{Return type}] \leavevmode
\sphinxAtStartPar
{\hyperref[\detokenize{MolOpt.genetic:MolOpt.genetic.genetic.Chromosome}]{\sphinxcrossref{Chromosome}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{Crossover (class in MolOpt.genetic.genetic)@\spxentry{Crossover}\spxextra{class in MolOpt.genetic.genetic}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MolOpt.genetic:MolOpt.genetic.genetic.Crossover}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{Crossover}}}{\emph{\DUrole{n}{methods}\DUrole{p}{:} \DUrole{n}{list{[}collections.abc.Callable{[}{[}MolOpt.genetic.genetic.Chromosome{]}, \textasciitilde{} Genes{]}{]}}}, \emph{\DUrole{n}{methods\_rate}\DUrole{p}{:} \DUrole{n}{list\DUrole{p}{{[}}typing.Union\DUrole{p}{{[}}int\DUrole{p}{, }float\DUrole{p}{{]}}\DUrole{p}{{]}}}}}{}
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
A container for storing crossover functions and its rates. When called it receives two Chromosome objects and 
returns a new Chromosome. This class is supposed to receive functions which receive two Chromosome objects and 
returns a random combination of their genes
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
Child Chromosome

\item[{Return type}] \leavevmode
\sphinxAtStartPar
{\hyperref[\detokenize{MolOpt.genetic:MolOpt.genetic.genetic.Chromosome}]{\sphinxcrossref{Chromosome}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{Genetic (class in MolOpt.genetic.genetic)@\spxentry{Genetic}\spxextra{class in MolOpt.genetic.genetic}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MolOpt.genetic:MolOpt.genetic.genetic.Genetic}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{Genetic}}}{\emph{\DUrole{n}{first\_genes}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{MolOpt.genetic:MolOpt.genetic.genetic.Chromosome}]{\sphinxcrossref{MolOpt.genetic.genetic.Chromosome}}}}}, \emph{\DUrole{n}{strategies}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{MolOpt.genetic:MolOpt.genetic.genetic.Strategies}]{\sphinxcrossref{MolOpt.genetic.genetic.Strategies}}}}}, \emph{\DUrole{n}{max\_age}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}int\DUrole{p}{{]}}}}, \emph{\DUrole{n}{pool\_size}\DUrole{p}{:} \DUrole{n}{int}}, \emph{\DUrole{n}{mutate\_after\_crossover}\DUrole{p}{:} \DUrole{n}{bool}}, \emph{\DUrole{n}{crossover\_elitism}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}list\DUrole{p}{{[}}typing.Union\DUrole{p}{{[}}int\DUrole{p}{, }float\DUrole{p}{{]}}\DUrole{p}{{]}}\DUrole{p}{{]}}}}, \emph{\DUrole{n}{elitism\_rate}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}list\DUrole{p}{{[}}int\DUrole{p}{{]}}\DUrole{p}{{]}}}}, \emph{\DUrole{n}{freedom\_rate}\DUrole{p}{:} \DUrole{n}{int}}, \emph{\DUrole{n}{parallelism}\DUrole{p}{:} \DUrole{n}{bool}}, \emph{\DUrole{n}{local\_opt}\DUrole{p}{:} \DUrole{n}{bool}}, \emph{\DUrole{n}{max\_seconds}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}Union\DUrole{p}{{[}}int\DUrole{p}{, }float\DUrole{p}{{]}}\DUrole{p}{{]}}}}, \emph{\DUrole{n}{time\_toler}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}Union\DUrole{p}{{[}}int\DUrole{p}{, }float\DUrole{p}{{]}}\DUrole{p}{{]}}}}, \emph{\DUrole{n}{gens\_toler}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}Union\DUrole{p}{{[}}int\DUrole{p}{, }float\DUrole{p}{{]}}\DUrole{p}{{]}}}}, \emph{\DUrole{n}{max\_gens}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}Union\DUrole{p}{{[}}int\DUrole{p}{, }float\DUrole{p}{{]}}\DUrole{p}{{]}}}}, \emph{\DUrole{n}{save\_directory}\DUrole{p}{:} \DUrole{n}{str}}}{}
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{abc.ABC}}

\sphinxAtStartPar
Genetic algorithm abstract class. This abstract class provides a framework for creating problem\sphinxhyphen{}specific genetic
algorithms. To use it you must create a class that inherits it. The class that inherits it must to have at least two
methods: get\_fitness and save
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ABC}} (\sphinxstyleliteralemphasis{\sphinxupquote{class}}) \textendash{} Helper class that provides a standard way to create an abstract class using inheritance

\end{description}\end{quote}
\index{\_\_generate\_parent() (Genetic method)@\spxentry{\_\_generate\_parent()}\spxextra{Genetic method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MolOpt.genetic:MolOpt.genetic.genetic.Genetic.__generate_parent}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_generate\_parent}}}{\emph{\DUrole{n}{queue}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}multiprocessing.context.BaseContext.Queue\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{label}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}str\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}}{}
\sphinxAtStartPar
Tries to generate a new candidate using the Create object from strategies inside a ‘while True’ loop with a 
‘try except’ statement which is broke when the new candidate is successfully generated. If an exception occurs 
during the candidate generation try, the function ‘catch’ will be called with such candidate as argument
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{queue}} (\sphinxstyleliteralemphasis{\sphinxupquote{mp.Queue}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Multiprocessing queue by which the candidates are returned in case of parallelism, defaults to 
None

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{label}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} New parent’s Chromosome’s label, defaults to None

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
New candidate

\item[{Return type}] \leavevmode
\sphinxAtStartPar
{\hyperref[\detokenize{MolOpt.genetic:MolOpt.genetic.genetic.Chromosome}]{\sphinxcrossref{Chromosome}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_get\_child() (Genetic method)@\spxentry{\_\_get\_child()}\spxextra{Genetic method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MolOpt.genetic:MolOpt.genetic.genetic.Genetic.__get_child}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_get\_child}}}{\emph{\DUrole{n}{candidates}\DUrole{p}{:} \DUrole{n}{list\DUrole{p}{{[}}{\hyperref[\detokenize{MolOpt.genetic:MolOpt.genetic.genetic.Chromosome}]{\sphinxcrossref{MolOpt.genetic.genetic.Chromosome}}}\DUrole{p}{{]}}}}, \emph{\DUrole{n}{parent\_index}\DUrole{p}{:} \DUrole{n}{int}}, \emph{\DUrole{n}{queue}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}multiprocessing.context.BaseContext.Queue\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{child\_index}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}int\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{label}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}str\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}}{}
\sphinxAtStartPar
Tries to generate a new candidate inside a ‘while True’ loop with a ‘try except’ statement which is broke 
when the new candidate is successfully generated. If an exception occurs during the candidate generation try, 
the function ‘catch’ will be called with such candidate as argument
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{candidates}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}{\hyperref[\detokenize{MolOpt.genetic:MolOpt.genetic.genetic.Chromosome}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Chromosome}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Pool of candidates

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{parent\_index}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Index of the current parent’s Chromosome in candidates

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{queue}} (\sphinxstyleliteralemphasis{\sphinxupquote{mp.Queue}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Multiprocessing queue by which the candidates are returned in case of parallelism, defaults to 
None

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{child\_index}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Index of child in the next generation pool. It’s used to identify the returned chromosome in
the main process in case of parallelism, defaults to None

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{label}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Child’s Chromosome’s label, defaults to None

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
Child

\item[{Return type}] \leavevmode
\sphinxAtStartPar
{\hyperref[\detokenize{MolOpt.genetic:MolOpt.genetic.genetic.Chromosome}]{\sphinxcrossref{Chromosome}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_get\_improvement() (Genetic method)@\spxentry{\_\_get\_improvement()}\spxextra{Genetic method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MolOpt.genetic:MolOpt.genetic.genetic.Genetic.__get_improvement}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_get\_improvement}}}{}{}
\sphinxAtStartPar
Generator of genetic improvements
\begin{quote}\begin{description}
\item[{Yield}] \leavevmode
\sphinxAtStartPar
Best candidate achieved until the moment

\item[{Return type}] \leavevmode
\sphinxAtStartPar
{\hyperref[\detokenize{MolOpt.genetic:MolOpt.genetic.genetic.Chromosome}]{\sphinxcrossref{Chromosome}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_get\_improvement\_mp() (Genetic method)@\spxentry{\_\_get\_improvement\_mp()}\spxextra{Genetic method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MolOpt.genetic:MolOpt.genetic.genetic.Genetic.__get_improvement_mp}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_get\_improvement\_mp}}}{}{}
\sphinxAtStartPar
Genetic improvements generator using multiprocessing
\begin{quote}\begin{description}
\item[{Raises}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{Exception}} \textendash{} Raises an exception if elitism rate is incompatible with pool size

\item[{Yield}] \leavevmode
\sphinxAtStartPar
Best candidate achieved until the moment

\item[{Return type}] \leavevmode
\sphinxAtStartPar
{\hyperref[\detokenize{MolOpt.genetic:MolOpt.genetic.genetic.Chromosome}]{\sphinxcrossref{Chromosome}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_local\_optimization() (Genetic method)@\spxentry{\_\_local\_optimization()}\spxextra{Genetic method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MolOpt.genetic:MolOpt.genetic.genetic.Genetic.__local_optimization}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_local\_optimization}}}{\emph{\DUrole{n}{candidate}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{MolOpt.genetic:MolOpt.genetic.genetic.Chromosome}]{\sphinxcrossref{MolOpt.genetic.genetic.Chromosome}}}}}}{{ $\rightarrow$ {\hyperref[\detokenize{MolOpt.genetic:MolOpt.genetic.genetic.Chromosome}]{\sphinxcrossref{MolOpt.genetic.genetic.Chromosome}}}}}
\sphinxAtStartPar
Receives a candidate then performs a local optimization on its genes and so returns a new Chromosome with
these new genes and its fitness
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{candidate}} ({\hyperref[\detokenize{MolOpt.genetic:MolOpt.genetic.genetic.Chromosome}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Chromosome}}}}}) \textendash{} Candidate which genes are wanted to be optimized

\item[{Returns}] \leavevmode
\sphinxAtStartPar
Optimized candidate

\item[{Return type}] \leavevmode
\sphinxAtStartPar
{\hyperref[\detokenize{MolOpt.genetic:MolOpt.genetic.genetic.Chromosome}]{\sphinxcrossref{Chromosome}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{catch() (Genetic static method)@\spxentry{catch()}\spxextra{Genetic static method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MolOpt.genetic:MolOpt.genetic.genetic.Genetic.catch}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxbfcode{\sphinxupquote{catch}}}{\emph{\DUrole{n}{candidate}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{MolOpt.genetic:MolOpt.genetic.genetic.Chromosome}]{\sphinxcrossref{MolOpt.genetic.genetic.Chromosome}}}}}}{{ $\rightarrow$ None}}
\sphinxAtStartPar
Static method which will be executed if an error occurs during a candidate generation. It can be override if 
needed. By default it just raises an exception
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{candidate}} ({\hyperref[\detokenize{MolOpt.genetic:MolOpt.genetic.genetic.Chromosome}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Chromosome}}}}}) \textendash{} Candidate which was being generated while error occurs

\item[{Raises}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{Exception}} \textendash{} Raises exception if error occurs during candidate generation

\end{description}\end{quote}

\end{fulllineitems}

\index{display() (Genetic static method)@\spxentry{display()}\spxextra{Genetic static method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MolOpt.genetic:MolOpt.genetic.genetic.Genetic.display}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxbfcode{\sphinxupquote{display}}}{\emph{\DUrole{n}{candidate}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{MolOpt.genetic:MolOpt.genetic.genetic.Chromosome}]{\sphinxcrossref{MolOpt.genetic.genetic.Chromosome}}}}}, \emph{\DUrole{n}{timediff}\DUrole{p}{:} \DUrole{n}{float}}}{{ $\rightarrow$ None}}
\sphinxAtStartPar
Generate what is printed on console everytime a new best candidate is reached. It can be override if needed
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{candidate}} ({\hyperref[\detokenize{MolOpt.genetic:MolOpt.genetic.genetic.Chromosome}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Chromosome}}}}}) \textendash{} Best candidate found

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{timediff}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Time difference between the candidate is found and the start of the execution

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_fitness() (Genetic method)@\spxentry{get\_fitness()}\spxextra{Genetic method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MolOpt.genetic:MolOpt.genetic.genetic.Genetic.get_fitness}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{abstract }}\sphinxbfcode{\sphinxupquote{get\_fitness}}}{\emph{\DUrole{n}{candidate}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{MolOpt.genetic:MolOpt.genetic.genetic.Chromosome}]{\sphinxcrossref{MolOpt.genetic.genetic.Chromosome}}}}}}{{ $\rightarrow$ MolOpt.genetic.genetic.Fitness}}
\sphinxAtStartPar
Abstract method which must be override by one which receives a candidate’s Chromosome and returns it’s
fitness
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{candidate}} (\sphinxstyleliteralemphasis{\sphinxupquote{Fitness}}) \textendash{} Candidate wich fitness is wanted

\item[{Return type}] \leavevmode
\sphinxAtStartPar
Fitness

\end{description}\end{quote}

\end{fulllineitems}

\index{load() (Genetic method)@\spxentry{load()}\spxextra{Genetic method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MolOpt.genetic:MolOpt.genetic.genetic.Genetic.load}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{load}}}{}{{ $\rightarrow$ {\hyperref[\detokenize{MolOpt.genetic:MolOpt.genetic.genetic.Chromosome}]{\sphinxcrossref{MolOpt.genetic.genetic.Chromosome}}}}}
\sphinxAtStartPar
Returns a Chromosome with the genes and the fitness of the first\_parent
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
Copy of first candidate

\item[{Return type}] \leavevmode
\sphinxAtStartPar
{\hyperref[\detokenize{MolOpt.genetic:MolOpt.genetic.genetic.Chromosome}]{\sphinxcrossref{Chromosome}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{local\_optimize() (Genetic method)@\spxentry{local\_optimize()}\spxextra{Genetic method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MolOpt.genetic:MolOpt.genetic.genetic.Genetic.local_optimize}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{local\_optimize}}}{\emph{\DUrole{n}{candidate}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{MolOpt.genetic:MolOpt.genetic.genetic.Chromosome}]{\sphinxcrossref{MolOpt.genetic.genetic.Chromosome}}}}}}{{ $\rightarrow$ MolOpt.genetic.genetic.Genes}}
\sphinxAtStartPar
This method must be override in case of local\_opt is True for a method which receives a candidate’s 
Chromosome and returns its genes locally optimized
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{candidate}} ({\hyperref[\detokenize{MolOpt.genetic:MolOpt.genetic.genetic.Chromosome}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Chromosome}}}}}) \textendash{} Candidate which genes are wanted to be optimized

\item[{Raises}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{Exception}} \textendash{} Raises exception if this method was not override by the subclass

\item[{Returns}] \leavevmode
\sphinxAtStartPar
Optimized genes

\item[{Return type}] \leavevmode
\sphinxAtStartPar
Genes

\end{description}\end{quote}

\end{fulllineitems}

\index{mutate\_best() (Genetic method)@\spxentry{mutate\_best()}\spxextra{Genetic method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MolOpt.genetic:MolOpt.genetic.genetic.Genetic.mutate_best}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{mutate\_best}}}{\emph{\DUrole{n}{best\_candidate}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{MolOpt.genetic:MolOpt.genetic.genetic.Chromosome}]{\sphinxcrossref{MolOpt.genetic.genetic.Chromosome}}}}}}{{ $\rightarrow$ MolOpt.genetic.genetic.Genes}}
\sphinxAtStartPar
The actual mutate\_best function. This is a creation function that receives the Chromosome of the best 
candidate and pass it to the Mutate object to return the result
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{best\_candidate}} ({\hyperref[\detokenize{MolOpt.genetic:MolOpt.genetic.genetic.Chromosome}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Chromosome}}}}}) \textendash{} Best candidate

\item[{Returns}] \leavevmode
\sphinxAtStartPar
Mutated genes of the best candidate

\item[{Return type}] \leavevmode
\sphinxAtStartPar
genes

\end{description}\end{quote}

\end{fulllineitems}

\index{mutate\_first() (Genetic method)@\spxentry{mutate\_first()}\spxextra{Genetic method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MolOpt.genetic:MolOpt.genetic.genetic.Genetic.mutate_first}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{mutate\_first}}}{\emph{\DUrole{n}{first\_parent}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{MolOpt.genetic:MolOpt.genetic.genetic.Chromosome}]{\sphinxcrossref{MolOpt.genetic.genetic.Chromosome}}}}}}{{ $\rightarrow$ MolOpt.genetic.genetic.Genes}}
\sphinxAtStartPar
The actual mutate\_first function. This is a creation function that receives the Chromosome of the first 
candidate and pass it to the Mutate object to return the result
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{first\_parent}} ({\hyperref[\detokenize{MolOpt.genetic:MolOpt.genetic.genetic.Chromosome}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Chromosome}}}}}) \textendash{} First created candidate

\item[{Returns}] \leavevmode
\sphinxAtStartPar
Mutated genes of the first candidate

\item[{Return type}] \leavevmode
\sphinxAtStartPar
genes

\end{description}\end{quote}

\end{fulllineitems}

\index{run() (Genetic method)@\spxentry{run()}\spxextra{Genetic method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MolOpt.genetic:MolOpt.genetic.genetic.Genetic.run}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{run}}}{}{{ $\rightarrow$ {\hyperref[\detokenize{MolOpt.genetic:MolOpt.genetic.genetic.Chromosome}]{\sphinxcrossref{MolOpt.genetic.genetic.Chromosome}}}}}
\sphinxAtStartPar
Starts the genetic algorithm execution
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
Best candidate

\item[{Return type}] \leavevmode
\sphinxAtStartPar
{\hyperref[\detokenize{MolOpt.genetic:MolOpt.genetic.genetic.Chromosome}]{\sphinxcrossref{Chromosome}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{save() (Genetic method)@\spxentry{save()}\spxextra{Genetic method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MolOpt.genetic:MolOpt.genetic.genetic.Genetic.save}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{abstract }}\sphinxbfcode{\sphinxupquote{save}}}{\emph{\DUrole{n}{candidate}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{MolOpt.genetic:MolOpt.genetic.genetic.Chromosome}]{\sphinxcrossref{MolOpt.genetic.genetic.Chromosome}}}}}, \emph{\DUrole{n}{file\_name}\DUrole{p}{:} \DUrole{n}{str}}, \emph{\DUrole{n}{directory}\DUrole{p}{:} \DUrole{n}{str}}}{{ $\rightarrow$ None}}
\sphinxAtStartPar
Abstract method which must be override by one which receives a candidate, a file\_name and a directory. This 
method which overrides it must receive a candidate’s Chromosome, a string which is the name of the file the 
candidate will be saved and a string which is the directory where it will be saved than this function must save 
the candidate relevant informations in a document named as given in the directory given. The directory is given 
relative to \_\_main\_\_
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{candidate}} ({\hyperref[\detokenize{MolOpt.genetic:MolOpt.genetic.genetic.Chromosome}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Chromosome}}}}}) \textendash{} Candidate which is wanted to save

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{file\_name}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Name of the file in which the candidate’s informations must be saved

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{directory}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Directory where the file with the candidate’s information must be saved

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{Mutate (class in MolOpt.genetic.genetic)@\spxentry{Mutate}\spxextra{class in MolOpt.genetic.genetic}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MolOpt.genetic:MolOpt.genetic.genetic.Mutate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{Mutate}}}{\emph{\DUrole{n}{methods}\DUrole{p}{:} \DUrole{n}{list{[}collections.abc.Callable{[}{[}MolOpt.genetic.genetic.Chromosome{]}, \textasciitilde{} Genes{]}{]}}}, \emph{\DUrole{n}{methods\_rate}\DUrole{p}{:} \DUrole{n}{list\DUrole{p}{{[}}typing.Union\DUrole{p}{{[}}int\DUrole{p}{, }float\DUrole{p}{{]}}\DUrole{p}{{]}}}}}{}
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
A container for storing mutation functions and its rates. When it’s called it receives a Chromosome and returns
a new Chromosome. This is supposed to receive functions which receives a Chromosome object and returns its genes 
with some random modification
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
Mutated Chromosome

\item[{Return type}] \leavevmode
\sphinxAtStartPar
{\hyperref[\detokenize{MolOpt.genetic:MolOpt.genetic.genetic.Chromosome}]{\sphinxcrossref{Chromosome}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{Strategies (class in MolOpt.genetic.genetic)@\spxentry{Strategies}\spxextra{class in MolOpt.genetic.genetic}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MolOpt.genetic:MolOpt.genetic.genetic.Strategies}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{Strategies}}}{\emph{\DUrole{n}{strategies}\DUrole{p}{:} \DUrole{n}{Tuple\DUrole{p}{{[}}{\hyperref[\detokenize{MolOpt.genetic:MolOpt.genetic.genetic.Mutate}]{\sphinxcrossref{MolOpt.genetic.genetic.Mutate}}}\DUrole{p}{, }{\hyperref[\detokenize{MolOpt.genetic:MolOpt.genetic.genetic.Crossover}]{\sphinxcrossref{MolOpt.genetic.genetic.Crossover}}}\DUrole{p}{, }{\hyperref[\detokenize{MolOpt.genetic:MolOpt.genetic.genetic.Create}]{\sphinxcrossref{MolOpt.genetic.genetic.Create}}}\DUrole{p}{{]}}}}, \emph{\DUrole{n}{strategies\_rate}\DUrole{p}{:} \DUrole{n}{list\DUrole{p}{{[}}typing.Union\DUrole{p}{{[}}int\DUrole{p}{, }float\DUrole{p}{{]}}\DUrole{p}{{]}}}}}{}
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
A container for sotoring the candidate generation strategies (Create, Mutate and Crossover objects) and its 
rates. It must receive only one of each generation strategy (Create, Mutate and Crossover) object
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
New Chromosome object with the genes generated by the strategy randomly selected

\item[{Return type}] \leavevmode
\sphinxAtStartPar
{\hyperref[\detokenize{MolOpt.genetic:MolOpt.genetic.genetic.Chromosome}]{\sphinxcrossref{Chromosome}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{mutate\_best() (in module MolOpt.genetic.genetic)@\spxentry{mutate\_best()}\spxextra{in module MolOpt.genetic.genetic}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MolOpt.genetic:MolOpt.genetic.genetic.mutate_best}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{mutate\_best}}}{\emph{\DUrole{n}{best\_candidate}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{MolOpt.genetic:MolOpt.genetic.genetic.Chromosome}]{\sphinxcrossref{MolOpt.genetic.genetic.Chromosome}}}}}}{{ $\rightarrow$ MolOpt.genetic.genetic.Genes}}
\sphinxAtStartPar
Creation function that receives the Chromosome of the best candidate and pass it to the Mutate object to return 
the result

\sphinxAtStartPar
This function is actually a void, it exists only to be called by import and to be override by the actual mutate\_best
function
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{best\_candidate}} ({\hyperref[\detokenize{MolOpt.genetic:MolOpt.genetic.genetic.Chromosome}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Chromosome}}}}}) \textendash{} Best candidate

\item[{Returns}] \leavevmode
\sphinxAtStartPar
Mutated genes of the best candidate

\item[{Return type}] \leavevmode
\sphinxAtStartPar
genes

\end{description}\end{quote}

\end{fulllineitems}

\index{mutate\_first() (in module MolOpt.genetic.genetic)@\spxentry{mutate\_first()}\spxextra{in module MolOpt.genetic.genetic}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MolOpt.genetic:MolOpt.genetic.genetic.mutate_first}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{mutate\_first}}}{\emph{\DUrole{n}{first\_parent}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{MolOpt.genetic:MolOpt.genetic.genetic.Chromosome}]{\sphinxcrossref{MolOpt.genetic.genetic.Chromosome}}}}}}{{ $\rightarrow$ MolOpt.genetic.genetic.Genes}}
\sphinxAtStartPar
Creation function that receives the Chromosome of the first created parent and pass it to the Mutate object to 
return the result

\sphinxAtStartPar
This function is actually a void, it exists only to be called by import and to be override by the actual 
mutate\_first function
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{first\_parent}} ({\hyperref[\detokenize{MolOpt.genetic:MolOpt.genetic.genetic.Chromosome}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Chromosome}}}}}) \textendash{} First created candidate

\item[{Returns}] \leavevmode
\sphinxAtStartPar
Mutated genes of the first candidate

\item[{Return type}] \leavevmode
\sphinxAtStartPar
genes

\end{description}\end{quote}

\end{fulllineitems}



\subsection{molecular subpackage}
\label{\detokenize{MolOpt.molecular:module-MolOpt.molecular.molecular}}\label{\detokenize{MolOpt.molecular:molecular-subpackage}}\label{\detokenize{MolOpt.molecular::doc}}\index{module@\spxentry{module}!MolOpt.molecular.molecular@\spxentry{MolOpt.molecular.molecular}}\index{MolOpt.molecular.molecular@\spxentry{MolOpt.molecular.molecular}!module@\spxentry{module}}\index{Molecule (class in MolOpt.molecular.molecular)@\spxentry{Molecule}\spxextra{class in MolOpt.molecular.molecular}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MolOpt.molecular:MolOpt.molecular.molecular.Molecule}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{Molecule}}}{\emph{\DUrole{n}{basis}\DUrole{p}{:} \DUrole{n}{str}}, \emph{\DUrole{n}{geometry}\DUrole{p}{:} \DUrole{n}{list\DUrole{p}{{[}}list\DUrole{p}{{[}}typing.Union\DUrole{p}{{[}}str\DUrole{p}{, }int\DUrole{p}{, }float\DUrole{p}{{]}}\DUrole{p}{{]}}\DUrole{p}{{]}}}}, \emph{\DUrole{n}{settings}\DUrole{p}{:} \DUrole{n}{list\DUrole{p}{{[}}str\DUrole{p}{{]}}}}, \emph{\DUrole{n}{parameters}\DUrole{p}{:} \DUrole{n}{dict\DUrole{p}{{[}}str\DUrole{p}{, }typing.Union\DUrole{p}{{[}}int\DUrole{p}{, }float\DUrole{p}{{]}}\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{\{\}}}, \emph{\DUrole{n}{rand\_range}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}Tuple\DUrole{p}{{[}}Union\DUrole{p}{{[}}int\DUrole{p}{, }float\DUrole{p}{{]}}\DUrole{p}{, }Union\DUrole{p}{{[}}int\DUrole{p}{, }float\DUrole{p}{{]}}\DUrole{p}{{]}}\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{label}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}str\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{output}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}str\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{output\_values}\DUrole{p}{:} \DUrole{n}{dict\DUrole{p}{{[}}str\DUrole{p}{, }typing.Union\DUrole{p}{{[}}int\DUrole{p}{, }float\DUrole{p}{{]}}\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{\{\}}}, \emph{\DUrole{n}{was\_optg}\DUrole{p}{:} \DUrole{n}{bool} \DUrole{o}{=} \DUrole{default_value}{False}}}{}
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
This class provides a framework for storing molecular geometry, generating Molpro inputs and store output 
information. It also brings functions to work with genetic algorithm.
\index{\_receive() (Molecule method)@\spxentry{\_receive()}\spxextra{Molecule method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MolOpt.molecular:MolOpt.molecular.molecular.Molecule._receive}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_receive}}}{\emph{\DUrole{n}{molecule}}}{{ $\rightarrow$ None}}
\sphinxAtStartPar
Receives all data from another molecule making the actual molecule its copy
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{molecule}} ({\hyperref[\detokenize{MolOpt.molecular:MolOpt.molecular.molecular.Molecule}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Molecule}}}}}) \textendash{} The data donor molecule

\end{description}\end{quote}

\end{fulllineitems}

\index{copy() (Molecule method)@\spxentry{copy()}\spxextra{Molecule method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MolOpt.molecular:MolOpt.molecular.molecular.Molecule.copy}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{copy}}}{}{{ $\rightarrow$ {\hyperref[\detokenize{MolOpt.molecular:MolOpt.molecular.molecular.Molecule}]{\sphinxcrossref{MolOpt.molecular.molecular.Molecule}}}}}
\sphinxAtStartPar
Returns a totally independent copy of itself
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
Copy of self

\item[{Return type}] \leavevmode
\sphinxAtStartPar
{\hyperref[\detokenize{MolOpt.molecular:MolOpt.molecular.molecular.Molecule}]{\sphinxcrossref{Molecule}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{dist\_unit (Molecule property)@\spxentry{dist\_unit}\spxextra{Molecule property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MolOpt.molecular:MolOpt.molecular.molecular.Molecule.dist_unit}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{dist\_unit}}\sphinxbfcode{\sphinxupquote{: str}}}
\sphinxAtStartPar
Gets the distance unit used to describe the molecule
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
Distance unit

\item[{Return type}] \leavevmode
\sphinxAtStartPar
str

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_value() (Molecule method)@\spxentry{get\_value()}\spxextra{Molecule method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MolOpt.molecular:MolOpt.molecular.molecular.Molecule.get_value}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_value}}}{\emph{\DUrole{n}{wanted}\DUrole{p}{:} \DUrole{n}{list\DUrole{p}{{[}}str\DUrole{p}{{]}}}}, \emph{\DUrole{n}{document}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}str\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{directory}\DUrole{p}{:} \DUrole{n}{str} \DUrole{o}{=} \DUrole{default_value}{\textquotesingle{}data\textquotesingle{}}}, \emph{\DUrole{n}{keep\_output}\DUrole{p}{:} \DUrole{n}{bool} \DUrole{o}{=} \DUrole{default_value}{False}}, \emph{\DUrole{n}{nthreads}\DUrole{p}{:} \DUrole{n}{int} \DUrole{o}{=} \DUrole{default_value}{1}}, \emph{\DUrole{n}{update\_self}\DUrole{p}{:} \DUrole{n}{bool} \DUrole{o}{=} \DUrole{default_value}{True}}}{{ $\rightarrow$ dict\DUrole{p}{{[}}str\DUrole{p}{, }float\DUrole{p}{{]}}}}
\sphinxAtStartPar
Reads the Molpro’s output file, searchs for wanted strings and gets the numeric value that is in the same row
then returns a dictionary where the keys are the wanted strings and the values are the numeric strings 
correspondents. If document.out already exists in /directory the document will be read and the values returned. 
If it doesn’t and document.inp already exists in directory, it will execute Molpro over the input. If neither 
document.out nor document.inp exists, document.inp will be created and Molpro executed over it and after 
document.inp will be deleted
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{wanted}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} list of variables to be search in the output. They must be the string which precedes the wanted
numeric value in molpro’s output

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{document}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Documents’ name, defaults to None

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{directory}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Directory adress where the input and the output will be relative to \_\_main\_\_, defaults to 
‘data’

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{keep\_output}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} If it’s True, the output will be kept and its name will be put in self.output, else it will 
be deleted after is read. defaults to False

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{nthreads}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Number of threads useds in Molpro calculation, defaults to 1

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{update\_self}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} If it’s True, self.output\_values will be updated with each item of wanted. If it’s False, 
self.output\_values will not be updated, and the output values will can only be accessed by the returned dict

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
Wanted strings and correspondent values

\item[{Return type}] \leavevmode
\sphinxAtStartPar
dict{[}str, float{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{load() (Molecule static method)@\spxentry{load()}\spxextra{Molecule static method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MolOpt.molecular:MolOpt.molecular.molecular.Molecule.load}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxbfcode{\sphinxupquote{load}}}{\emph{\DUrole{n}{file}\DUrole{p}{:} \DUrole{n}{str}}, \emph{\DUrole{n}{rand\_range}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}Tuple\DUrole{p}{{[}}Union\DUrole{p}{{[}}int\DUrole{p}{, }float\DUrole{p}{{]}}\DUrole{p}{, }Union\DUrole{p}{{[}}int\DUrole{p}{, }float\DUrole{p}{{]}}\DUrole{p}{{]}}\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{label}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}str\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{output}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}str\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{output\_values}\DUrole{p}{:} \DUrole{n}{dict\DUrole{p}{{[}}str\DUrole{p}{, }typing.Union\DUrole{p}{{[}}int\DUrole{p}{, }float\DUrole{p}{{]}}\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{\{\}}}, \emph{\DUrole{n}{was\_optg}\DUrole{p}{:} \DUrole{n}{bool} \DUrole{o}{=} \DUrole{default_value}{False}}}{{ $\rightarrow$ {\hyperref[\detokenize{MolOpt.molecular:MolOpt.molecular.molecular.Molecule}]{\sphinxcrossref{MolOpt.molecular.molecular.Molecule}}}}}
\sphinxAtStartPar
Loads a molecule from a .inp document and returns its Molecule object
 \\
 \\The file must have the one of the following structures:
 \\
 \\****,
 \\
 \\basis=\{
 \\!
 \\! aluminium            (6s,4p) \sphinxhyphen{}\textgreater{} {[}3s,2p{]}
 \\s, AL , 0.5605994123E+00, 0.1923360636E+00, 0.7304329554E+01, 0.1852570854E+01, 0.1343774607E+03, 0.2391912027E+02
 \\c, 1.2, \sphinxhyphen{}0.2983986045E+00, 0.1227982887E+01
 \\c, 3.4, 0.4947176920E\sphinxhyphen{}01, 0.9637824081E+00
 \\c, 5.6, 0.4301284983E+00, 0.6789135305E+00
 \\p, AL , 0.7304329554E+01, 0.1852570854E+01, 0.5605994123E+00, 0.1923360636E+00
 \\c, 1.2, 0.5115407076E+00, 0.6128198961E+00
 \\c, 3.4, 0.3480471912E+00, 0.7222523221E+00
 \\\}
 \\
 \\r1=2.706
 \\r2=2.414
 \\r3=2.481
 \\r4=2.817
 \\r5=2.529
 \\r6=2.547
 \\r7=2.510
 \\r8=2.401
 \\r9=2.666
 \\t1=66.357
 \\t2=65.256
 \\t3=115.675
 \\t4=107.280
 \\t5=105.113
 \\t6=97.637
 \\t7=104.449
 \\t8=63.620
 \\a1=104.0
 \\a2=89.4
 \\a3=345.8
 \\a4=272.6
 \\a5=43.5
 \\a6=341.2
 \\a7=238.2
 \\
 \\geometry=\{ang
 \\Al
 \\Al,  1,     r1
 \\Al,  2,     r2 ,    1,      t1
 \\Al,  2,     r3 ,    1,     t2,       3,    a1
 \\Al,  3,     r4 ,    2,     t3,       1,     a2
 \\Al,  1,     r5 ,    2,     t4,       3,    a3
 \\Al,  5,     r6 ,    3,     t5,       2,    a4
 \\Al,  7,     r7,     5,      t6,      3,     a5
 \\Al,  5,     r8,     3,      t7,      2,    a6
 \\Al,  4,     r9,     2,      t8,      1,     a7
 \\\}
 \\
 \\SET,CHARGE=0
 \\direct
 \\\{ks, b3lyp,maxit=200\}
 \\
 \\\sphinxhyphen{}\sphinxhyphen{}\sphinxhyphen{}
 \\
 \\or 
 \\
 \\****,
 \\
 \\basis=\{
 \\!
 \\! aluminium            (6s,4p) \sphinxhyphen{}\textgreater{} {[}3s,2p{]}
 \\s, AL , 0.5605994123E+00, 0.1923360636E+00, 0.7304329554E+01, 0.1852570854E+01, 0.1343774607E+03, 0.2391912027E+02
 \\c, 1.2, \sphinxhyphen{}0.2983986045E+00, 0.1227982887E+01
 \\c, 3.4, 0.4947176920E\sphinxhyphen{}01, 0.9637824081E+00
 \\c, 5.6, 0.4301284983E+00, 0.6789135305E+00
 \\p, AL , 0.7304329554E+01, 0.1852570854E+01, 0.5605994123E+00, 0.1923360636E+00
 \\c, 1.2, 0.5115407076E+00, 0.6128198961E+00
 \\c, 3.4, 0.3480471912E+00, 0.7222523221E+00
 \\\}
 \\
 \\geometry=\{ang
 \\Al
 \\Al,  1,     2.706
 \\Al,  2,     2.414,     1,      66.357
 \\Al,  2,     2.481,     1,      65.256,       3,     104.0
 \\Al,  3,     2.817,     2,      115.675,      1,     89.4
 \\Al,  1,     2.529,     2,      107.280,      3,     345.8
 \\Al,  5,     2.547,     3,      105.113,      2,     272.6
 \\Al,  7,     2.510,     5,      97.637,       3,     43.5
 \\Al,  5,     2.401,     3,      104.449,      2,     341.2
 \\Al,  4,     2.666,     2,      63.620,       1,     238.2
 \\\}
 \\
 \\SET,CHARGE=0
 \\direct
 \\\{ks, b3lyp,maxit=200\}
 \\
 \\\sphinxhyphen{}\sphinxhyphen{}\sphinxhyphen{}
 \\
 \\Respecting empty lines between different sections of the file. That is, it must have one empty line between
each section of the file. Here we can see we can have until six sections in the file: the beggining’s section or
just ‘***,’, the basis’ section, the parameters’ section (that can exists or don’t), the geometry’s section, 
the settings’ section and the end section or just ‘\sphinxhyphen{}\sphinxhyphen{}\sphinxhyphen{}’. The order of the sections also must respect the
order of the chosen structure. The second structure, that is the structure with literal numbers inside the
geometry brackets is not compatible with optg function, so the first structure, that is the one with declared
variables before the geometry is aways recommended
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{file}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} File name, it must end with .inp but the .inp may not be included here

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{rand\_range}} (\sphinxstyleliteralemphasis{\sphinxupquote{Tuple}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{numeric}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{numeric}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Min and max values that can be generated when distances are mutated, defaults to None

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{label}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} A tag which can be used to identify the object, defaults to None

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{output}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} The address of the molecule’s .out document generated by Molpro, defaults to None

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{output\_values}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{numeric}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Values extracted from the output document, defaults to dict()

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{was\_optg}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} True if the geometry was already optmized with optg, false if it doesn’t

\end{itemize}

\item[{Raises}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{Exception}} \textendash{} Invalid Z\sphinxhyphen{}matrix

\item[{Returns}] \leavevmode
\sphinxAtStartPar
Loaded molecule

\item[{Return type}] \leavevmode
\sphinxAtStartPar
{\hyperref[\detokenize{MolOpt.molecular:MolOpt.molecular.molecular.Molecule}]{\sphinxcrossref{Molecule}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{mutate\_angles() (Molecule method)@\spxentry{mutate\_angles()}\spxextra{Molecule method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MolOpt.molecular:MolOpt.molecular.molecular.Molecule.mutate_angles}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{mutate\_angles}}}{\emph{\DUrole{n}{times}\DUrole{p}{:} \DUrole{n}{int} \DUrole{o}{=} \DUrole{default_value}{1}}}{{ $\rightarrow$ {\hyperref[\detokenize{MolOpt.molecular:MolOpt.molecular.molecular.Molecule}]{\sphinxcrossref{MolOpt.molecular.molecular.Molecule}}}}}
\sphinxAtStartPar
Selects a random angle parameter from the geometry and assign it a random value between 0 and 360 degrees. 
This process is repeated an amount of times equal to times
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{times}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Number of mutations, defaults to 1

\item[{Returns}] \leavevmode
\sphinxAtStartPar
Itself mutated

\item[{Return type}] \leavevmode
\sphinxAtStartPar
{\hyperref[\detokenize{MolOpt.molecular:MolOpt.molecular.molecular.Molecule}]{\sphinxcrossref{Molecule}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{mutate\_distances() (Molecule method)@\spxentry{mutate\_distances()}\spxextra{Molecule method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MolOpt.molecular:MolOpt.molecular.molecular.Molecule.mutate_distances}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{mutate\_distances}}}{\emph{\DUrole{n}{times}\DUrole{p}{:} \DUrole{n}{int} \DUrole{o}{=} \DUrole{default_value}{1}}}{{ $\rightarrow$ {\hyperref[\detokenize{MolOpt.molecular:MolOpt.molecular.molecular.Molecule}]{\sphinxcrossref{MolOpt.molecular.molecular.Molecule}}}}}
\sphinxAtStartPar
Selects a random distance parameter from the geometry and assign it a random value in the range gave by 
rand\_range. This process is repeated a number of times equal to times
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{times}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of mutations, defaults to 1

\item[{Returns}] \leavevmode
\sphinxAtStartPar
Itself mutated

\item[{Return type}] \leavevmode
\sphinxAtStartPar
{\hyperref[\detokenize{MolOpt.molecular:MolOpt.molecular.molecular.Molecule}]{\sphinxcrossref{Molecule}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{optg() (Molecule method)@\spxentry{optg()}\spxextra{Molecule method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MolOpt.molecular:MolOpt.molecular.molecular.Molecule.optg}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{optg}}}{\emph{\DUrole{n}{wanted}\DUrole{p}{:} \DUrole{n}{list\DUrole{p}{{[}}str\DUrole{p}{{]}}}}, \emph{\DUrole{n}{directory}\DUrole{p}{:} \DUrole{n}{str} \DUrole{o}{=} \DUrole{default_value}{\textquotesingle{}data\textquotesingle{}}}, \emph{\DUrole{n}{nthreads}\DUrole{p}{:} \DUrole{n}{int} \DUrole{o}{=} \DUrole{default_value}{1}}, \emph{\DUrole{n}{keep\_output}\DUrole{o}{=}\DUrole{default_value}{False}}}{{ $\rightarrow$ {\hyperref[\detokenize{MolOpt.molecular:MolOpt.molecular.molecular.Molecule}]{\sphinxcrossref{MolOpt.molecular.molecular.Molecule}}}}}
\sphinxAtStartPar
Turns the molecule in its own geometric optimized version
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{wanted}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} list of variables to be search in the output

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{directory}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Directory adress where the input and the output will be relative to \_\_main\_\_, defaults to 
‘data’

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{nthreads}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Number of threads useds in Molpro calculation, defaults to 1

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{keep\_output}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} If it’s True, the output will be kept, else it will be deleted after be read. 
defaults to False

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
Itself optmized version

\item[{Return type}] \leavevmode
\sphinxAtStartPar
{\hyperref[\detokenize{MolOpt.molecular:MolOpt.molecular.molecular.Molecule}]{\sphinxcrossref{Molecule}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{save() (Molecule method)@\spxentry{save()}\spxextra{Molecule method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MolOpt.molecular:MolOpt.molecular.molecular.Molecule.save}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{save}}}{\emph{\DUrole{n}{document}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}str\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{directory}\DUrole{p}{:} \DUrole{n}{str} \DUrole{o}{=} \DUrole{default_value}{\textquotesingle{}data\textquotesingle{}}}}{{ $\rightarrow$ None}}
\sphinxAtStartPar
Saves the object data in document.inp. If document receives None it’ll be the molecule’s label, if it still 
None it will be str(self.\_\_hash\_\_()). If the directory didn’t exist it wil be created
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{document}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Document’s name, defaults to None

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{directory}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Directory where the document will be saved, defaults to ‘data’

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{swap\_mutate() (Molecule method)@\spxentry{swap\_mutate()}\spxextra{Molecule method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MolOpt.molecular:MolOpt.molecular.molecular.Molecule.swap_mutate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{swap\_mutate}}}{}{{ $\rightarrow$ {\hyperref[\detokenize{MolOpt.molecular:MolOpt.molecular.molecular.Molecule}]{\sphinxcrossref{MolOpt.molecular.molecular.Molecule}}}}}
\sphinxAtStartPar
Provokes a swap mutation in itsef
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
Itself mutated

\item[{Return type}] \leavevmode
\sphinxAtStartPar
{\hyperref[\detokenize{MolOpt.molecular:MolOpt.molecular.molecular.Molecule}]{\sphinxcrossref{Molecule}}}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{\_get\_swap\_indexes() (in module MolOpt.molecular.molecular)@\spxentry{\_get\_swap\_indexes()}\spxextra{in module MolOpt.molecular.molecular}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MolOpt.molecular:MolOpt.molecular.molecular._get_swap_indexes}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_get\_swap\_indexes}}}{\emph{\DUrole{n}{new\_molecule}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{MolOpt.molecular:MolOpt.molecular.molecular.Molecule}]{\sphinxcrossref{MolOpt.molecular.molecular.Molecule}}}}}}{{ $\rightarrow$ Tuple\DUrole{p}{{[}}int\DUrole{p}{, }int\DUrole{p}{, }int\DUrole{p}{, }int\DUrole{p}{{]}}}}
\sphinxAtStartPar
Randomly choices the indexes of the parameters that will be swapped
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{new\_molecule}} ({\hyperref[\detokenize{MolOpt.molecular:MolOpt.molecular.molecular.Molecule}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Molecule}}}}}) \textendash{} Copy of the original moecule

\item[{Returns}] \leavevmode
\sphinxAtStartPar
A tuple with the four indexes needed to perform the swap

\item[{Return type}] \leavevmode
\sphinxAtStartPar
Tuple{[}int, int, int, int{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{crossover\_1() (in module MolOpt.molecular.molecular)@\spxentry{crossover\_1()}\spxextra{in module MolOpt.molecular.molecular}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MolOpt.molecular:MolOpt.molecular.molecular.crossover_1}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{crossover\_1}}}{\emph{\DUrole{n}{parent}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{MolOpt.molecular:MolOpt.molecular.molecular.Molecule}]{\sphinxcrossref{MolOpt.molecular.molecular.Molecule}}}}}, \emph{\DUrole{n}{donor}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{MolOpt.molecular:MolOpt.molecular.molecular.Molecule}]{\sphinxcrossref{MolOpt.molecular.molecular.Molecule}}}}}, \emph{\DUrole{n}{label}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}str\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}}{{ $\rightarrow$ {\hyperref[\detokenize{MolOpt.molecular:MolOpt.molecular.molecular.Molecule}]{\sphinxcrossref{MolOpt.molecular.molecular.Molecule}}}}}
\sphinxAtStartPar
Creates a copy of the parent molecule then randomly choices a row and a ‘column’ from the geometry and there 
divides the geometry in two pieces. Then randomly pick one of these pieces and attach with the complementar part 
provided by the donor molecule generating the geometry of the child molecule
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{parent}} ({\hyperref[\detokenize{MolOpt.molecular:MolOpt.molecular.molecular.Molecule}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Molecule}}}}}) \textendash{} Parent molecule

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{donor}} ({\hyperref[\detokenize{MolOpt.molecular:MolOpt.molecular.molecular.Molecule}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Molecule}}}}}) \textendash{} Donor molecule

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{label}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} A tag which can be used to identify the child molecule, defaults to None

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
Child molecule

\item[{Return type}] \leavevmode
\sphinxAtStartPar
{\hyperref[\detokenize{MolOpt.molecular:MolOpt.molecular.molecular.Molecule}]{\sphinxcrossref{Molecule}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{crossover\_2() (in module MolOpt.molecular.molecular)@\spxentry{crossover\_2()}\spxextra{in module MolOpt.molecular.molecular}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MolOpt.molecular:MolOpt.molecular.molecular.crossover_2}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{crossover\_2}}}{\emph{\DUrole{n}{parent}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{MolOpt.molecular:MolOpt.molecular.molecular.Molecule}]{\sphinxcrossref{MolOpt.molecular.molecular.Molecule}}}}}, \emph{\DUrole{n}{donor}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{MolOpt.molecular:MolOpt.molecular.molecular.Molecule}]{\sphinxcrossref{MolOpt.molecular.molecular.Molecule}}}}}, \emph{\DUrole{n}{label}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}str\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}}{{ $\rightarrow$ {\hyperref[\detokenize{MolOpt.molecular:MolOpt.molecular.molecular.Molecule}]{\sphinxcrossref{MolOpt.molecular.molecular.Molecule}}}}}
\sphinxAtStartPar
Randomly cuts the parent molecule’s geometry in two points. The sequence between these two points will either 
replace its correspondent in the donor molecule’s geometry or be replaced by it (randomly) generating the geometry
of the child molecule that will be returned. At leas four atoms are needed to realize this process. Trying it with
molecules smaller than it will raise an exception
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{parent}} ({\hyperref[\detokenize{MolOpt.molecular:MolOpt.molecular.molecular.Molecule}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Molecule}}}}}) \textendash{} Parent molecule

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{donor}} ({\hyperref[\detokenize{MolOpt.molecular:MolOpt.molecular.molecular.Molecule}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Molecule}}}}}) \textendash{} Donor molecule

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{label}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} A tag which can be used to identify the child molecule, defaults to None

\end{itemize}

\item[{Raises}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{Exception}} \textendash{} At least 4 atoms are needed to perform crossover\_2

\item[{Returns}] \leavevmode
\sphinxAtStartPar
child Molecule

\item[{Return type}] \leavevmode
\sphinxAtStartPar
{\hyperref[\detokenize{MolOpt.molecular:MolOpt.molecular.molecular.Molecule}]{\sphinxcrossref{Molecule}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{crossover\_n() (in module MolOpt.molecular.molecular)@\spxentry{crossover\_n()}\spxextra{in module MolOpt.molecular.molecular}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MolOpt.molecular:MolOpt.molecular.molecular.crossover_n}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{crossover\_n}}}{\emph{\DUrole{n}{parent}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{MolOpt.molecular:MolOpt.molecular.molecular.Molecule}]{\sphinxcrossref{MolOpt.molecular.molecular.Molecule}}}}}, \emph{\DUrole{n}{donor}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{MolOpt.molecular:MolOpt.molecular.molecular.Molecule}]{\sphinxcrossref{MolOpt.molecular.molecular.Molecule}}}}}, \emph{\DUrole{n}{label}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}str\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}}{{ $\rightarrow$ {\hyperref[\detokenize{MolOpt.molecular:MolOpt.molecular.molecular.Molecule}]{\sphinxcrossref{MolOpt.molecular.molecular.Molecule}}}}}
\sphinxAtStartPar
Creates a copy of the parent molecule, randomly choices an amount of parameters the minimun being one and the 
maximun being the total amount of parameters minus one. Then randomly choices this amount of parameters from the 
donor molecule to replace the respectives parameters the child molecule inherited from parent molecule
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{parent}} ({\hyperref[\detokenize{MolOpt.molecular:MolOpt.molecular.molecular.Molecule}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Molecule}}}}}) \textendash{} Parent molecule

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{donor}} ({\hyperref[\detokenize{MolOpt.molecular:MolOpt.molecular.molecular.Molecule}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Molecule}}}}}) \textendash{} Donor molecule

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{label}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} A tag which can be used to identify the child molecule, defaults to None

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
Child molecule

\item[{Return type}] \leavevmode
\sphinxAtStartPar
{\hyperref[\detokenize{MolOpt.molecular:MolOpt.molecular.molecular.Molecule}]{\sphinxcrossref{Molecule}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{mutate\_angles() (in module MolOpt.molecular.molecular)@\spxentry{mutate\_angles()}\spxextra{in module MolOpt.molecular.molecular}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MolOpt.molecular:MolOpt.molecular.molecular.mutate_angles}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{mutate\_angles}}}{\emph{\DUrole{n}{molecule}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{MolOpt.molecular:MolOpt.molecular.molecular.Molecule}]{\sphinxcrossref{MolOpt.molecular.molecular.Molecule}}}}}, \emph{\DUrole{n}{times}\DUrole{p}{:} \DUrole{n}{int} \DUrole{o}{=} \DUrole{default_value}{1}}, \emph{\DUrole{n}{label}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}str\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}}{{ $\rightarrow$ {\hyperref[\detokenize{MolOpt.molecular:MolOpt.molecular.molecular.Molecule}]{\sphinxcrossref{MolOpt.molecular.molecular.Molecule}}}}}
\sphinxAtStartPar
Creates a moecule’s copy and randomly choices an angle parameter and set it value to a random value between 0 and
360. The amount of mutations performed is equal times
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{molecule}} ({\hyperref[\detokenize{MolOpt.molecular:MolOpt.molecular.molecular.Molecule}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Molecule}}}}}) \textendash{} Original molecule

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{times}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Amount of angle mutations, defaults to 1

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{label}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Label of the new molecule, defaults to None

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
New molecule

\item[{Return type}] \leavevmode
\sphinxAtStartPar
{\hyperref[\detokenize{MolOpt.molecular:MolOpt.molecular.molecular.Molecule}]{\sphinxcrossref{Molecule}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{mutate\_distances() (in module MolOpt.molecular.molecular)@\spxentry{mutate\_distances()}\spxextra{in module MolOpt.molecular.molecular}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MolOpt.molecular:MolOpt.molecular.molecular.mutate_distances}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{mutate\_distances}}}{\emph{\DUrole{n}{molecule}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{MolOpt.molecular:MolOpt.molecular.molecular.Molecule}]{\sphinxcrossref{MolOpt.molecular.molecular.Molecule}}}}}, \emph{\DUrole{n}{times}\DUrole{p}{:} \DUrole{n}{int} \DUrole{o}{=} \DUrole{default_value}{1}}, \emph{\DUrole{n}{label}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}str\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}}{{ $\rightarrow$ {\hyperref[\detokenize{MolOpt.molecular:MolOpt.molecular.molecular.Molecule}]{\sphinxcrossref{MolOpt.molecular.molecular.Molecule}}}}}
\sphinxAtStartPar
Creates a moecule’s copy and randomly choices a distance parameter and set it value in the range gave by 
rand\_range. The amount of mutations performed is equal times
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{molecule}} ({\hyperref[\detokenize{MolOpt.molecular:MolOpt.molecular.molecular.Molecule}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Molecule}}}}}) \textendash{} Original molecule

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{times}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Amount of angle mutations, defaults to 1

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{label}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Label of the new molecule, defaults to None

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
New molecule

\item[{Return type}] \leavevmode
\sphinxAtStartPar
{\hyperref[\detokenize{MolOpt.molecular:MolOpt.molecular.molecular.Molecule}]{\sphinxcrossref{Molecule}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{optg() (in module MolOpt.molecular.molecular)@\spxentry{optg()}\spxextra{in module MolOpt.molecular.molecular}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MolOpt.molecular:MolOpt.molecular.molecular.optg}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{optg}}}{\emph{\DUrole{n}{molecule}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{MolOpt.molecular:MolOpt.molecular.molecular.Molecule}]{\sphinxcrossref{MolOpt.molecular.molecular.Molecule}}}}}, \emph{\DUrole{n}{wanted\_energy}\DUrole{p}{:} \DUrole{n}{str}}, \emph{\DUrole{n}{directory}\DUrole{p}{:} \DUrole{n}{str} \DUrole{o}{=} \DUrole{default_value}{\textquotesingle{}data\textquotesingle{}}}, \emph{\DUrole{n}{nthreads}\DUrole{p}{:} \DUrole{n}{int} \DUrole{o}{=} \DUrole{default_value}{1}}, \emph{\DUrole{n}{keep\_output}\DUrole{p}{:} \DUrole{n}{bool} \DUrole{o}{=} \DUrole{default_value}{False}}}{{ $\rightarrow$ {\hyperref[\detokenize{MolOpt.molecular:MolOpt.molecular.molecular.Molecule}]{\sphinxcrossref{MolOpt.molecular.molecular.Molecule}}}}}
\sphinxAtStartPar
Creates a copy of the original molecule, appends ‘optg’ in the settings if it’s not already there and calls the 
get\_value function with it. Then updates the wanted\_energy in optmized\_molecule.output\_values and updates all angles
and distances parameters in {[}optmized\_molecule.parameters{]}. To use this function there cannont be any literal value 
in the molecule’s geometry, all values must be as variables names in geometry and has its literal values declared in
molecule.parameters
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{molecule}} ({\hyperref[\detokenize{MolOpt.molecular:MolOpt.molecular.molecular.Molecule}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Molecule}}}}}) \textendash{} Original molecule

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{wanted\_energy}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} The key wanted for the energy in optimized\_molecule.output\_values

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{directory}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Directory adress where the input and the output will be relative to \_\_main\_\_, defaults to ‘data’

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{nthreads}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Number of threads useds in Molpro calculation, defaults to 1

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{keep\_output}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} If it’s True, the output will be kept and its name will be put in self.output, else it will be 
deleted after is read. defaults to False

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
Optmized molecule

\item[{Return type}] \leavevmode
\sphinxAtStartPar
{\hyperref[\detokenize{MolOpt.molecular:MolOpt.molecular.molecular.Molecule}]{\sphinxcrossref{Molecule}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{random\_molecule() (in module MolOpt.molecular.molecular)@\spxentry{random\_molecule()}\spxextra{in module MolOpt.molecular.molecular}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MolOpt.molecular:MolOpt.molecular.molecular.random_molecule}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{random\_molecule}}}{\emph{\DUrole{n}{molecular\_formula}\DUrole{p}{:} \DUrole{n}{str}}, \emph{\DUrole{n}{basis}\DUrole{p}{:} \DUrole{n}{str}}, \emph{\DUrole{n}{settings}\DUrole{p}{:} \DUrole{n}{list\DUrole{p}{{[}}str\DUrole{p}{{]}}}}, \emph{\DUrole{n}{rand\_range}\DUrole{p}{:} \DUrole{n}{Tuple\DUrole{p}{{[}}Union\DUrole{p}{{[}}int\DUrole{p}{, }float\DUrole{p}{{]}}\DUrole{p}{, }Union\DUrole{p}{{[}}int\DUrole{p}{, }float\DUrole{p}{{]}}\DUrole{p}{{]}}}}, \emph{\DUrole{n}{label}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}str\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{dist\_unit}\DUrole{p}{:} \DUrole{n}{str} \DUrole{o}{=} \DUrole{default_value}{\textquotesingle{}ang\textquotesingle{}}}}{{ $\rightarrow$ {\hyperref[\detokenize{MolOpt.molecular:MolOpt.molecular.molecular.Molecule}]{\sphinxcrossref{MolOpt.molecular.molecular.Molecule}}}}}
\sphinxAtStartPar
Creates a geometry with all distances parameters randomized in the range gave by rand\_range and all angles 
randomized between 0 and 360 given the molecular formula which is a string containing the elements followed by its 
amount like’H2O’, ‘C6H12O6’, ‘Al10’… It doesn’t support parenthesys and is invariant to the order of elements. 
What matters in molecular\_formula is which number follows which element
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{molecular\_formula}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} The molecular formula of the wanted molecule

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{basis}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Hilbert space basis

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{settings}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Molpro calculation settings

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{rand\_range}} (\sphinxstyleliteralemphasis{\sphinxupquote{Tuple}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{numeric}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{numeric}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Min and max values that can be generated when distances are mutated

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{label}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} A tag which can be used to identify the molecule, defaults to None

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{dist\_unit}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Distance unit, defaults to ‘ang’

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
Random molecule

\item[{Return type}] \leavevmode
\sphinxAtStartPar
{\hyperref[\detokenize{MolOpt.molecular:MolOpt.molecular.molecular.Molecule}]{\sphinxcrossref{Molecule}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{randomize() (in module MolOpt.molecular.molecular)@\spxentry{randomize()}\spxextra{in module MolOpt.molecular.molecular}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MolOpt.molecular:MolOpt.molecular.molecular.randomize}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{randomize}}}{\emph{\DUrole{n}{molecule}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{MolOpt.molecular:MolOpt.molecular.molecular.Molecule}]{\sphinxcrossref{MolOpt.molecular.molecular.Molecule}}}}}, \emph{\DUrole{n}{label}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}str\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}}{{ $\rightarrow$ {\hyperref[\detokenize{MolOpt.molecular:MolOpt.molecular.molecular.Molecule}]{\sphinxcrossref{MolOpt.molecular.molecular.Molecule}}}}}
\sphinxAtStartPar
Creates a molecule’s copy and replace all distance parameters with random values in the range gave by rand\_range 
and replace all angle parameters with random values between 0 and 360
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{molecule}} ({\hyperref[\detokenize{MolOpt.molecular:MolOpt.molecular.molecular.Molecule}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Molecule}}}}}) \textendash{} Original molecule

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{label}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} A tag which can be used to identify the new molecule, defaults to None

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
New molecule

\item[{Return type}] \leavevmode
\sphinxAtStartPar
{\hyperref[\detokenize{MolOpt.molecular:MolOpt.molecular.molecular.Molecule}]{\sphinxcrossref{Molecule}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{swap\_mutate() (in module MolOpt.molecular.molecular)@\spxentry{swap\_mutate()}\spxextra{in module MolOpt.molecular.molecular}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MolOpt.molecular:MolOpt.molecular.molecular.swap_mutate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{swap\_mutate}}}{\emph{\DUrole{n}{molecule}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{MolOpt.molecular:MolOpt.molecular.molecular.Molecule}]{\sphinxcrossref{MolOpt.molecular.molecular.Molecule}}}}}, \emph{\DUrole{n}{times}\DUrole{p}{:} \DUrole{n}{int} \DUrole{o}{=} \DUrole{default_value}{1}}, \emph{\DUrole{n}{label}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}str\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}}{{ $\rightarrow$ {\hyperref[\detokenize{MolOpt.molecular:MolOpt.molecular.molecular.Molecule}]{\sphinxcrossref{MolOpt.molecular.molecular.Molecule}}}}}
\sphinxAtStartPar
Creates a molecule’s copy and randomly swap parameters of its places. It makes a amount of random swaps equal 
times.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{molecule}} ({\hyperref[\detokenize{MolOpt.molecular:MolOpt.molecular.molecular.Molecule}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Molecule}}}}}) \textendash{} Original molecule

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{times}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Number of random swaps, defaults to 1

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{label}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Label of the new molecule, defaults to None

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
New molecule

\item[{Return type}] \leavevmode
\sphinxAtStartPar
{\hyperref[\detokenize{MolOpt.molecular:MolOpt.molecular.molecular.Molecule}]{\sphinxcrossref{Molecule}}}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{MolOpt.MolOpt module}
\label{\detokenize{MolOpt:module-MolOpt.MolOpt}}\label{\detokenize{MolOpt:molopt-molopt-module}}\index{module@\spxentry{module}!MolOpt.MolOpt@\spxentry{MolOpt.MolOpt}}\index{MolOpt.MolOpt@\spxentry{MolOpt.MolOpt}!module@\spxentry{module}}\index{MolOpt (class in MolOpt.MolOpt)@\spxentry{MolOpt}\spxextra{class in MolOpt.MolOpt}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MolOpt:MolOpt.MolOpt.MolOpt}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{MolOpt}}}{\emph{\DUrole{n}{first\_molecule}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{MolOpt.molecular:MolOpt.molecular.molecular.Molecule}]{\sphinxcrossref{MolOpt.molecular.molecular.Molecule}}}}}, \emph{\DUrole{n}{energy\_param}\DUrole{p}{:} \DUrole{n}{str}}, \emph{\DUrole{n}{strategies}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{MolOpt.genetic:MolOpt.genetic.genetic.Strategies}]{\sphinxcrossref{MolOpt.genetic.genetic.Strategies}}}}}, \emph{\DUrole{n}{max\_age}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}int\DUrole{p}{{]}}}}, \emph{\DUrole{n}{pool\_size}\DUrole{p}{:} \DUrole{n}{int}}, \emph{\DUrole{n}{mutate\_after\_crossover}\DUrole{p}{:} \DUrole{n}{bool}}, \emph{\DUrole{n}{crossover\_elitism}\DUrole{p}{:} \DUrole{n}{list\DUrole{p}{{[}}int\DUrole{p}{{]}}}}, \emph{\DUrole{n}{elitism\_rate}\DUrole{p}{:} \DUrole{n}{list\DUrole{p}{{[}}int\DUrole{p}{{]}}}}, \emph{\DUrole{n}{freedom\_rate}\DUrole{p}{:} \DUrole{n}{int}}, \emph{\DUrole{n}{parallelism}\DUrole{p}{:} \DUrole{n}{bool}}, \emph{\DUrole{n}{local\_opt}\DUrole{p}{:} \DUrole{n}{bool}}, \emph{\DUrole{n}{max\_seconds}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}Union\DUrole{p}{{[}}int\DUrole{p}{, }float\DUrole{p}{{]}}\DUrole{p}{{]}}}}, \emph{\DUrole{n}{time\_toler}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}Union\DUrole{p}{{[}}int\DUrole{p}{, }float\DUrole{p}{{]}}\DUrole{p}{{]}}}}, \emph{\DUrole{n}{gens\_toler}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}int\DUrole{p}{{]}}}}, \emph{\DUrole{n}{max\_gens}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}int\DUrole{p}{{]}}}}, \emph{\DUrole{n}{save\_directory}\DUrole{p}{:} \DUrole{n}{str}}, \emph{\DUrole{n}{threads\_per\_calc}\DUrole{p}{:} \DUrole{n}{int}}}{}
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{MolOpt.genetic:MolOpt.genetic.genetic.Genetic}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{MolOpt.genetic.genetic.Genetic}}}}}

\sphinxAtStartPar
Molecular geometry optimization class
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{Genetic}} (\sphinxstyleliteralemphasis{\sphinxupquote{ABC}}) \textendash{} Genetic algorithm abstract class

\end{description}\end{quote}
\index{catch() (MolOpt static method)@\spxentry{catch()}\spxextra{MolOpt static method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MolOpt:MolOpt.MolOpt.MolOpt.catch}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxbfcode{\sphinxupquote{catch}}}{\emph{\DUrole{n}{candidate}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{MolOpt.genetic:MolOpt.genetic.genetic.Chromosome}]{\sphinxcrossref{MolOpt.genetic.genetic.Chromosome}}}}}}{{ $\rightarrow$ None}}
\sphinxAtStartPar
Static method which will be executed if an error occurs during a candidate generation
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{candidate}} ({\hyperref[\detokenize{MolOpt.genetic:MolOpt.genetic.genetic.Chromosome}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Chromosome}}}}}) \textendash{} Candidate which during generation some exception occurred

\end{description}\end{quote}

\end{fulllineitems}

\index{crossover\_1() (MolOpt static method)@\spxentry{crossover\_1()}\spxextra{MolOpt static method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MolOpt:MolOpt.MolOpt.MolOpt.crossover_1}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxbfcode{\sphinxupquote{crossover\_1}}}{\emph{\DUrole{n}{parent}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{MolOpt.genetic:MolOpt.genetic.genetic.Chromosome}]{\sphinxcrossref{MolOpt.genetic.genetic.Chromosome}}}}}, \emph{\DUrole{n}{donor}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{MolOpt.genetic:MolOpt.genetic.genetic.Chromosome}]{\sphinxcrossref{MolOpt.genetic.genetic.Chromosome}}}}}}{{ $\rightarrow$ {\hyperref[\detokenize{MolOpt.molecular:MolOpt.molecular.molecular.Molecule}]{\sphinxcrossref{MolOpt.molecular.molecular.Molecule}}}}}
\sphinxAtStartPar
Produces a new molecule with the crossover of parent’s and donor’s molecules by cutting each one in one point
and combining the resultant pieces.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{parent}} ({\hyperref[\detokenize{MolOpt.genetic:MolOpt.genetic.genetic.Chromosome}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Chromosome}}}}}) \textendash{} Candidate which Molecule will suffer crossover\_1

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{donor}} ({\hyperref[\detokenize{MolOpt.genetic:MolOpt.genetic.genetic.Chromosome}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Chromosome}}}}}) \textendash{} Candidate which will donate parameters for the crossover\_1 operation

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
Child molecule

\item[{Return type}] \leavevmode
\sphinxAtStartPar
{\hyperref[\detokenize{MolOpt.molecular:MolOpt.molecular.molecular.Molecule}]{\sphinxcrossref{Molecule}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{crossover\_2() (MolOpt static method)@\spxentry{crossover\_2()}\spxextra{MolOpt static method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MolOpt:MolOpt.MolOpt.MolOpt.crossover_2}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxbfcode{\sphinxupquote{crossover\_2}}}{\emph{\DUrole{n}{parent}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{MolOpt.genetic:MolOpt.genetic.genetic.Chromosome}]{\sphinxcrossref{MolOpt.genetic.genetic.Chromosome}}}}}, \emph{\DUrole{n}{donor}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{MolOpt.genetic:MolOpt.genetic.genetic.Chromosome}]{\sphinxcrossref{MolOpt.genetic.genetic.Chromosome}}}}}}{{ $\rightarrow$ {\hyperref[\detokenize{MolOpt.molecular:MolOpt.molecular.molecular.Molecule}]{\sphinxcrossref{MolOpt.molecular.molecular.Molecule}}}}}
\sphinxAtStartPar
Produces a new molecule with the crossover of parent’s and donor’s molecules by cutting each one in two 
points and combining the resultant pieces
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{parent}} ({\hyperref[\detokenize{MolOpt.genetic:MolOpt.genetic.genetic.Chromosome}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Chromosome}}}}}) \textendash{} Candidate which Molecule will suffer crossover\_1

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{donor}} ({\hyperref[\detokenize{MolOpt.genetic:MolOpt.genetic.genetic.Chromosome}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Chromosome}}}}}) \textendash{} Candidate which will donate parameters for the crossover\_1 operation

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
Child molecule

\item[{Return type}] \leavevmode
\sphinxAtStartPar
{\hyperref[\detokenize{MolOpt.molecular:MolOpt.molecular.molecular.Molecule}]{\sphinxcrossref{Molecule}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{crossover\_n() (MolOpt static method)@\spxentry{crossover\_n()}\spxextra{MolOpt static method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MolOpt:MolOpt.MolOpt.MolOpt.crossover_n}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxbfcode{\sphinxupquote{crossover\_n}}}{\emph{\DUrole{n}{parent}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{MolOpt.genetic:MolOpt.genetic.genetic.Chromosome}]{\sphinxcrossref{MolOpt.genetic.genetic.Chromosome}}}}}, \emph{\DUrole{n}{donor}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{MolOpt.genetic:MolOpt.genetic.genetic.Chromosome}]{\sphinxcrossref{MolOpt.genetic.genetic.Chromosome}}}}}}{{ $\rightarrow$ {\hyperref[\detokenize{MolOpt.molecular:MolOpt.molecular.molecular.Molecule}]{\sphinxcrossref{MolOpt.molecular.molecular.Molecule}}}}}
\sphinxAtStartPar
Returns a new molecule which randomly carries parameters from the parent’s and donor’s molecules
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{parent}} ({\hyperref[\detokenize{MolOpt.genetic:MolOpt.genetic.genetic.Chromosome}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Chromosome}}}}}) \textendash{} Candidate which Molecule will suffer crossover\_1

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{donor}} ({\hyperref[\detokenize{MolOpt.genetic:MolOpt.genetic.genetic.Chromosome}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Chromosome}}}}}) \textendash{} Candidate which will donate parameters for the crossover\_1 operation

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
Child molecule

\item[{Return type}] \leavevmode
\sphinxAtStartPar
{\hyperref[\detokenize{MolOpt.molecular:MolOpt.molecular.molecular.Molecule}]{\sphinxcrossref{Molecule}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_fitness() (MolOpt method)@\spxentry{get\_fitness()}\spxextra{MolOpt method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MolOpt:MolOpt.MolOpt.MolOpt.get_fitness}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_fitness}}}{\emph{\DUrole{n}{candidate}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{MolOpt.genetic:MolOpt.genetic.genetic.Chromosome}]{\sphinxcrossref{MolOpt.genetic.genetic.Chromosome}}}}}}{{ $\rightarrow$ float}}
\sphinxAtStartPar
Receives a candidate’s Chromosome and returns its fitness
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{candidate}} ({\hyperref[\detokenize{MolOpt.genetic:MolOpt.genetic.genetic.Chromosome}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Chromosome}}}}}) \textendash{} Candidate which fitness must be calculated

\item[{Returns}] \leavevmode
\sphinxAtStartPar
Candidate’s fitness

\item[{Return type}] \leavevmode
\sphinxAtStartPar
float

\end{description}\end{quote}

\end{fulllineitems}

\index{local\_optimize() (MolOpt method)@\spxentry{local\_optimize()}\spxextra{MolOpt method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MolOpt:MolOpt.MolOpt.MolOpt.local_optimize}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{local\_optimize}}}{\emph{\DUrole{n}{candidate}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{MolOpt.genetic:MolOpt.genetic.genetic.Chromosome}]{\sphinxcrossref{MolOpt.genetic.genetic.Chromosome}}}}}}{{ $\rightarrow$ {\hyperref[\detokenize{MolOpt.molecular:MolOpt.molecular.molecular.Molecule}]{\sphinxcrossref{MolOpt.molecular.molecular.Molecule}}}}}
\sphinxAtStartPar
Executes geometric optimization over the candidate’s molecule using Molpro and returns a new molecule with 
the optimized geometry
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{candidate}} ({\hyperref[\detokenize{MolOpt.genetic:MolOpt.genetic.genetic.Chromosome}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Chromosome}}}}}) \textendash{} Candidate which Molecule will suffer local\_optimize operation

\item[{Returns}] \leavevmode
\sphinxAtStartPar
Optimized molecule

\item[{Return type}] \leavevmode
\sphinxAtStartPar
{\hyperref[\detokenize{MolOpt.molecular:MolOpt.molecular.molecular.Molecule}]{\sphinxcrossref{Molecule}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{mutate\_angles() (MolOpt static method)@\spxentry{mutate\_angles()}\spxextra{MolOpt static method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MolOpt:MolOpt.MolOpt.MolOpt.mutate_angles}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxbfcode{\sphinxupquote{mutate\_angles}}}{\emph{\DUrole{n}{parent}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{MolOpt.genetic:MolOpt.genetic.genetic.Chromosome}]{\sphinxcrossref{MolOpt.genetic.genetic.Chromosome}}}}}}{{ $\rightarrow$ {\hyperref[\detokenize{MolOpt.molecular:MolOpt.molecular.molecular.Molecule}]{\sphinxcrossref{MolOpt.molecular.molecular.Molecule}}}}}
\sphinxAtStartPar
Returns parent’s molecule’s copy with some random angle parameter randomized between 0 and 360 degrees
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{parent}} ({\hyperref[\detokenize{MolOpt.genetic:MolOpt.genetic.genetic.Chromosome}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Chromosome}}}}}) \textendash{} Candidate which Molecule will suffer mutate\_angles

\item[{Returns}] \leavevmode
\sphinxAtStartPar
New molecule

\item[{Return type}] \leavevmode
\sphinxAtStartPar
{\hyperref[\detokenize{MolOpt.molecular:MolOpt.molecular.molecular.Molecule}]{\sphinxcrossref{Molecule}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{mutate\_distances() (MolOpt static method)@\spxentry{mutate\_distances()}\spxextra{MolOpt static method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MolOpt:MolOpt.MolOpt.MolOpt.mutate_distances}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxbfcode{\sphinxupquote{mutate\_distances}}}{\emph{\DUrole{n}{parent}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{MolOpt.genetic:MolOpt.genetic.genetic.Chromosome}]{\sphinxcrossref{MolOpt.genetic.genetic.Chromosome}}}}}}{{ $\rightarrow$ {\hyperref[\detokenize{MolOpt.molecular:MolOpt.molecular.molecular.Molecule}]{\sphinxcrossref{MolOpt.molecular.molecular.Molecule}}}}}
\sphinxAtStartPar
Returns a parent’s molecule’s copy with some random distance parameter randomized in the range gave by 
parent.genes.rand\_range
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{parent}} ({\hyperref[\detokenize{MolOpt.genetic:MolOpt.genetic.genetic.Chromosome}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Chromosome}}}}}) \textendash{} Candidate which Molecule will suffer mutate\_distances

\item[{Returns}] \leavevmode
\sphinxAtStartPar
New molecule

\item[{Return type}] \leavevmode
\sphinxAtStartPar
{\hyperref[\detokenize{MolOpt.molecular:MolOpt.molecular.molecular.Molecule}]{\sphinxcrossref{Molecule}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{randomize() (MolOpt static method)@\spxentry{randomize()}\spxextra{MolOpt static method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MolOpt:MolOpt.MolOpt.MolOpt.randomize}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxbfcode{\sphinxupquote{randomize}}}{\emph{\DUrole{n}{parent}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{MolOpt.genetic:MolOpt.genetic.genetic.Chromosome}]{\sphinxcrossref{MolOpt.genetic.genetic.Chromosome}}}}}}{{ $\rightarrow$ {\hyperref[\detokenize{MolOpt.molecular:MolOpt.molecular.molecular.Molecule}]{\sphinxcrossref{MolOpt.molecular.molecular.Molecule}}}}}
\sphinxAtStartPar
Returns a parent’s molecule’s copy with all distances and angles parameters randomized
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{parent}} ({\hyperref[\detokenize{MolOpt.genetic:MolOpt.genetic.genetic.Chromosome}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Chromosome}}}}}) \textendash{} Candidate which Molecule will suffer randomize operation

\item[{Returns}] \leavevmode
\sphinxAtStartPar
New molecule

\item[{Return type}] \leavevmode
\sphinxAtStartPar
{\hyperref[\detokenize{MolOpt.molecular:MolOpt.molecular.molecular.Molecule}]{\sphinxcrossref{Molecule}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{save() (MolOpt static method)@\spxentry{save()}\spxextra{MolOpt static method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MolOpt:MolOpt.MolOpt.MolOpt.save}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxbfcode{\sphinxupquote{save}}}{\emph{\DUrole{n}{candidate}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{MolOpt.genetic:MolOpt.genetic.genetic.Chromosome}]{\sphinxcrossref{MolOpt.genetic.genetic.Chromosome}}}}}, \emph{\DUrole{n}{file\_name}\DUrole{p}{:} \DUrole{n}{str}}, \emph{\DUrole{n}{directory}\DUrole{p}{:} \DUrole{n}{str}}}{{ $\rightarrow$ None}}
\sphinxAtStartPar
Saves the candidate data in a .inp document
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{candidate}} ({\hyperref[\detokenize{MolOpt.genetic:MolOpt.genetic.genetic.Chromosome}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Chromosome}}}}}) \textendash{} Candidate which data will be saved

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{file\_name}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Document’s name

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{directory}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Directory where the document will be saved

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{swap\_mutate() (MolOpt static method)@\spxentry{swap\_mutate()}\spxextra{MolOpt static method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MolOpt:MolOpt.MolOpt.MolOpt.swap_mutate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxbfcode{\sphinxupquote{swap\_mutate}}}{\emph{\DUrole{n}{parent}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{MolOpt.genetic:MolOpt.genetic.genetic.Chromosome}]{\sphinxcrossref{MolOpt.genetic.genetic.Chromosome}}}}}}{{ $\rightarrow$ {\hyperref[\detokenize{MolOpt.molecular:MolOpt.molecular.molecular.Molecule}]{\sphinxcrossref{MolOpt.molecular.molecular.Molecule}}}}}
\sphinxAtStartPar
Returns a parent’s molecule’s copy with randomly swapped places parameters
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{parent}} ({\hyperref[\detokenize{MolOpt.genetic:MolOpt.genetic.genetic.Chromosome}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Chromosome}}}}}) \textendash{} Candidate which Molecule will suffer swap\_mutate

\item[{Returns}] \leavevmode
\sphinxAtStartPar
New molecule

\item[{Return type}] \leavevmode
\sphinxAtStartPar
{\hyperref[\detokenize{MolOpt.molecular:MolOpt.molecular.molecular.Molecule}]{\sphinxcrossref{Molecule}}}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\chapter{Indices and tables}
\label{\detokenize{index:indices-and-tables}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\sphinxAtStartPar
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\sphinxAtStartPar
\DUrole{xref,std,std-ref}{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\let\bigletter\sphinxstyleindexlettergroup
\bigletter{m}
\item\relax\sphinxstyleindexentry{MolOpt.genetic.genetic}\sphinxstyleindexpageref{MolOpt.genetic:\detokenize{module-MolOpt.genetic.genetic}}
\item\relax\sphinxstyleindexentry{MolOpt.molecular.molecular}\sphinxstyleindexpageref{MolOpt.molecular:\detokenize{module-MolOpt.molecular.molecular}}
\item\relax\sphinxstyleindexentry{MolOpt.MolOpt}\sphinxstyleindexpageref{MolOpt:\detokenize{module-MolOpt.MolOpt}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}
from __future__ import annotations
import re
import random
import os
import copy
from typing import Tuple


"""Framework for dealing with molecular structures and genetic algorithm compatible with Molpro
"""


numeric = int | float


class Molecule:
    """This class provides a framework for storing molecular geometry, generating Molpro inputs and store output 
    information. It also brings functions to work with genetic algorithm.
    """
    __slots__ = ('basis', 'parameters', 'geometry', 'settings', 'rand_range', 'label', 'output_values', 'output',
        'optg_result', 'was_optg')
    
    def __init__(self, basis: str, geometry: list[list[str | numeric]], settings: list[str], 
        parameters: dict[str, numeric] = dict(), rand_range: Tuple[numeric, numeric] = None, label: str = None, 
        output: str = None, output_values: dict[str, numeric] = dict(), was_optg: bool = False) -> Molecule:
        """Initializes the Molecule object by receiving its parameters
        
        :param basis: Hilbert space basis
        :type basis: str
        :param geometry: Z-matrix input
        :type geometry: list[list[str | numeric]]
        :param settings: Molpro calculation settings
        :type settings: list[str]
        :param parameters: The values of geometry variables, defaults to dict()
        :type parameters: dict[str, numeric], optional
        :param rand_range: Min and max values that can be generated when distances are mutated, defaults to None
        :type rand_range: Tuple[numeric, numeric], optional
        :param label: A tag which can be used to identify the Molecule object, defaults to None
        :type label: str, optional
        :param output: The address of the molecule's .out document generated by Molpro, defaults to None
        :type output: str, optional
        :param output_values: Values extracted from the output document, defaults to dict()
        :type output_values: dict[str, numeric], optional
        :param was_optg: True if the geometry was already optmized with optg, false if it doesn't
        :type was_optg: bool, optional
        """
        self.basis = basis
        self.parameters = parameters
        self.geometry = geometry
        self.settings = settings
        self.rand_range = rand_range
        self.label = label
        self.output = output
        self.output_values = output_values
        self.was_optg = was_optg

    @property
    def dist_unit(self) -> str:
        """Gets the distance unit used to describe the molecule

        :return: Distance unit
        :rtype: str
        """
        return self.geometry[0][0]

    @property
    def parameters_indexes(self) -> list[list[int, int]]:
        """Returns the indexes of all distance/angle parameters in the z-matrix

        :return: List of parameters' indexes
        :rtype: list[list[int, int]]
        """
        if len(self.geometry) <= 2:
            return []
        elif len(self.geometry) == 3:
            return [[2, 2]]
        return [[2, 2], [3, 2], [3, 4]] + [[i, j] for i in range(4, len(self.geometry)) for j in [2, 4, 6]]

    @property
    def distances_indexes(self) -> list[list[int, int]]:
        """Returns the indexes of all distance parameters in the z-matrix

        :return: List of parameters' indexes
        :rtype: list[list[int, int]]
        """
        if len(self.geometry) <= 2:
            return []
        return [[n, 2] for n in range(2, len(self.geometry))]

    @property
    def angles_indexes(self) -> list[list[int, int]]:
        """Returns the indexes of all angle parameters in the z-matrix

        :return: List of parameters' indexes
        :rtype: list[list[int, int]]
        """
        if len(self.geometry) <= 3:
            return []
        elif len(self.geometry) == 4:
            return [[3, 4]]
        return [[3,4]] + [[i, j] for i in range(4, len(self.geometry)) for j in [4, 6]]

    def random_distance(self) -> float:
        """Returns a random number in the interval given by rand_range of the object

        :return: Random number
        :rtype: float
        """
        return random.uniform(self.rand_range[0], self.rand_range[1])

    def random_compatible_indexes(self, amount: int = 2) -> list[list[int, int]]:
        """Returns an amount of random indexes of the z-matrix with all indexes being of the same kind of parameter,
        either distance or angle

        :param amount: Amount of random compatible indexes, defaults to 2
        :type amount: int, optional
        :raises Exception: Raises an exception if there are less than three atoms
        :return: Indexes
        :rtype: list[list[int, int]]
        """
        if len(self.geometry) < 4:
            raise  Exception('At least 3 atoms are needed')
        elif len(self.geometry) == 4:
            return [[2, 2], [3, 2]]
        elif random.choices([True, False], [len(self.distances_indexes), len(self.angles_indexes)])[0]:
            return random.sample(self.distances_indexes, amount)
        else:
            return random.sample(self.angles_indexes, amount)

    def randomize(self, label:str = None) -> Molecule:
        self._receive(randomize(self, label))

    def __str__(self) -> str:
        """Returns the Molpro input string

        :return: Molpro input string
        :rtype: str
        """
        string = f'***,\n\nbasis={self.basis}\n\n'
        if len(self.parameters) > 0:
            for k, v in zip(self.parameters.keys(), self.parameters.values()):
                string += f'{k}={v}\n'
        else:
            string = string[:-1]
        string += '\ngeometry={'
        for row in self.geometry:
            string += str(row).replace('[', '').replace(']', '').replace('\'', '') + '\n'
        string += '}\n\n'
        for setting in self.settings:
            string += setting + '\n'
        string += '\n---'
        return string
    
    def save(self, document: str = None, directory: str = 'data') -> None:
        """Saves the object data in document.inp. If document receives None it'll be the molecule's label, if it still 
        None it will be str(self.__hash__()). If the directory didn't exist it wil be created

        :param document: Document's name, defaults to None
        :type document: str, optional
        :param directory: Directory where the document will be saved, defaults to 'data'
        :type directory: str, optional
        """
        document = document if document is not None else self.label if\
             self.label is not None else str(self.__hash__())
        if directory == '':
            with open(f'{document}.inp', 'w') as file:
                file.write(str(self))
        else:
            if not os.path.exists(directory):
                os.mkdir(directory)
            with open(f'{directory}/{document}.inp', 'w') as file:
                file.write(str(self))

    def get_value(self, wanted: list[str], document: str = None, directory: str = 'data', keep_output: bool = False, 
        nthreads: int = 1, update_self: bool = True) -> dict[str, float]:
        """Reads the Molpro's output file, searchs for wanted strings and gets the numeric value that is in the same row
        then returns a dictionary where the keys are the wanted strings and the values are the numeric strings 
        correspondents. If document.out already exists in /directory the document will be read and the values returned. 
        If it doesn't and document.inp already exists in directory, it will execute Molpro over the input. If neither 
        document.out nor document.inp exists, document.inp will be created and Molpro executed over it and after 
        document.inp will be deleted

        :param wanted: list of variables to be search in the output. They must be the string which precedes the wanted
            numeric value in molpro's output
        :type wanted: list[str]
        :param document: Documents' name, defaults to None
        :type document: str, optional
        :param directory: Directory adress where the input and the output will be relative to __main__, defaults to 
            'data'
        :type directory: str, optional
        :param keep_output: If it's True, the output will be kept and its name will be put in self.output, else it will 
            be deleted after is read. defaults to False
        :type keep_output: bool, optional
        :param nthreads: Number of threads useds in Molpro calculation, defaults to 1
        :type nthreads: int, optional
        :param update_self: If it's True, self.output_values will be updated with each item of wanted. If it's False, 
            self.output_values will not be updated, and the output values will can only be accessed by the returned dict
        :type update_self: bool, optional
        :return: Wanted strings and correspondent values
        :rtype: dict[str, float]
        """
        document = document if document is not None else self.label if self.label is not None else str(self.__hash__())
        deldoc = False
        output_dictionary = self.output_values if update_self else dict()
        if not os.path.exists(f'{directory}/{document}.out'):
            if not os.path.exists(f'{directory}/{document}.inp'):
                self.save(document, directory)
                deldoc = True
            os.system(f'molpro -n {nthreads} ./{directory}/{document}.inp')
        with open(f'{directory}/{document}.out', 'r') as file:
            outstr = file.read()
            if 'No convergence' in outstr:
                raise Exception('No convergence')
        for item in wanted:
            output_dictionary.update({item: float(re.search('-*[0-9.]+', re.search(f'{item}.*', outstr)[0]\
                .replace(item, ''))[0])})
        if deldoc:
            os.remove(f'{directory}/{document}.inp')
        if not keep_output:
            os.remove(f'{directory}/{document}.xml')
            os.remove(f'{directory}/{document}.out')
        else:
            self.output = f'{directory}/{document}.out'
        return output_dictionary

    def optg(self, wanted: list[str], directory: str = 'data', nthreads: int = 1, keep_output= False) -> None:
        """Turns the molecule in its own geometric optimized version

        :param wanted: list of variables to be search in the output
        :type wanted: list[str]
        :param directory: Directory adress where the input and the output will be relative to __main__, defaults to 
            'data'
        :type directory: str, optional
        :param nthreads: Number of threads useds in Molpro calculation, defaults to 1
        :type nthreads: int, optional
        :param keep_output: If it's True, the output will be kept, else it will be deleted after be read. 
            defaults to False
        :type keep_output: bool, optional
        """
        self._receive(optg(self, wanted, directory, nthreads, keep_output))
    
    def copy(self) -> Molecule:
        """Returns a totally independent copy of itself

        :return: Deepcopy of itself
        :rtype: Molecule
        """
        return copy.deepcopy(self)
    
    def swap_mutate(self, times: int = 1, label: str = None) -> None:
        """Provokes a swap mutation in itsef

        :param times: Amount of mutations, defaults to 1
        :type times: int
        :param label: A tag which can be used to identify the object. If it's None it will preserve the current label, 
            defaults to None
        :type label: str, optional
        """
        label = label if label is not None else self.label
        self._receive(swap_mutate(self, times, label))

    def _receive(self, molecule) -> None:
        """Receives all data from another molecule making the actual molecule its copy

        :param molecule: The data donor molecule
        :type molecule: Molecule
        """
        self.basis = molecule.basis
        self.parameters = molecule.parameters
        self.geometry = molecule.geometry
        self.settings = molecule.settings
        self.rand_range = molecule.rand_range
        self.label = molecule.label
        self.output = molecule.output
        self.output_values = molecule.output_values

    def mutate_distances(self, times: int = 1, label: str = None) -> None:
        """Selects a random distance parameter from the geometry and assign it a random value in the range gave by 
        rand_range. This process is repeated a number of times equal to times

        :param times: Amount of mutations, defaults to 1
        :type times: int
        :param label: A tag which can be used to identify the object. If it's None it will preserve the current label, 
            defaults to None
        :type label: str, optional
        """
        label = label if label is not None else self.label
        self._receive(mutate_distances(self, times, label))

    def ieq_mutate(self, times: int = 1, label: str = None) -> None:
        """Randomly chooses two parameters of the same kind (either distance or angle) and set one to be equal to the
        other

        :param times: Amount of mutations, defaults to 1
        :type times: int, optional
        :param label: A tag which can be used to identify the object. If it's None it will preserve the current label, 
            defaults to None
        :type label: str, optional
        """
        label = label if label is not None else self.label
        self._receive(ieq_mutate(self, times, label))
    
    def mutate_angles(self, times: int = 1, label: str = None) -> None:
        """Selects a random angle parameter from the geometry and assign it a random value between 0 and 360 degrees. 
        This process is repeated an amount of times equal to times

        :param times: Amount of mutations, defaults to 1
        :type times: int, optional
        :param label: A tag which can be used to identify the object. If it's None it will preserve the current label, 
            defaults to None
        :type label: str, optional
        """
        label = label if label is not None else self.label
        self._receive(mutate_angles(self, times, label))

    def atom_displacement_mutate(self, times: int = 1, label: str = None) -> None:
        """Randomly selects an atom and randomly changes all it's positional parameters

        :param times: Amount of mutations that will be done, defaults to 1
        :type times: int, optional
        :param label: A tag which can be used to identify the object. If it's None it will preserve the current label, 
            defaults to None
        :type label: str, optional
        """
        label = label if label is not None else self.label
        self._receive(atom_displacement_mutate(self, times, label))

    def atom_swap_mutate(self, times: int = 1, label: str = None) -> None:
        """Randomly select two atoms and swaps its positions

        :param times: Amount of mutations that will be done, defaults to 1
        :type times: int, optional
        :param label: A tag which can be used to identify the object. If it's None it will preserve the current label, 
            defaults to None
        :type label: str, optional
        """        
        label = label if label is not None else self.label
        self._receive(atom_swap_mutate(self, times, label))

    @staticmethod
    def load(file: str, rand_range: Tuple[numeric, numeric] = None, label: str = None, output: str = None, 
        output_values: dict[str, numeric] = dict(), was_optg: bool = False) -> Molecule:
        """Loads a molecule from a .inp document and returns its Molecule object
        
        The file must have the one of the following structures:
        
        ***,
        
        basis={
        !
        ! aluminium            (6s,4p) -> [3s,2p]
        s, AL , 0.5605994123E+00, 0.1923360636E+00, 0.7304329554E+01, 0.1852570854E+01, 0.1343774607E+03, 0.2391912027E+02
        c, 1.2, -0.2983986045E+00, 0.1227982887E+01
        c, 3.4, 0.4947176920E-01, 0.9637824081E+00
        c, 5.6, 0.4301284983E+00, 0.6789135305E+00
        p, AL , 0.7304329554E+01, 0.1852570854E+01, 0.5605994123E+00, 0.1923360636E+00
        c, 1.2, 0.5115407076E+00, 0.6128198961E+00
        c, 3.4, 0.3480471912E+00, 0.7222523221E+00
        }
        
        r1=2.706
        r2=2.414
        r3=2.481
        r4=2.817
        r5=2.529
        r6=2.547
        r7=2.510
        r8=2.401
        r9=2.666
        t1=66.357
        t2=65.256
        t3=115.675
        t4=107.280
        t5=105.113
        t6=97.637
        t7=104.449
        t8=63.620
        a1=104.0
        a2=89.4
        a3=345.8
        a4=272.6
        a5=43.5
        a6=341.2
        a7=238.2
        
        geometry={ang
        Al
        Al, 1, r1
        Al, 2, r2, 1, t1
        Al, 2, r3, 1, t2, 3, a1
        Al, 3, r4, 2, t3, 1, a2
        Al, 1, r5, 2, t4, 3, a3
        Al, 5, r6, 3, t5, 2, a4
        Al, 7, r7, 5, t6, 3, a5
        Al, 5, r8, 3, t7, 2, a6
        Al, 4, r9, 2, t8, 1, a7
        }
        
        SET,CHARGE=0
        direct
        {ks, b3lyp,maxit=200}
        
        ---
        
        or 
        
        ***,
        
        basis={
        !
        ! aluminium            (6s,4p) -> [3s,2p]
        s, AL , 0.5605994123E+00, 0.1923360636E+00, 0.7304329554E+01, 0.1852570854E+01, 0.1343774607E+03, 0.2391912027E+02
        c, 1.2, -0.2983986045E+00, 0.1227982887E+01
        c, 3.4, 0.4947176920E-01, 0.9637824081E+00
        c, 5.6, 0.4301284983E+00, 0.6789135305E+00
        p, AL , 0.7304329554E+01, 0.1852570854E+01, 0.5605994123E+00, 0.1923360636E+00
        c, 1.2, 0.5115407076E+00, 0.6128198961E+00
        c, 3.4, 0.3480471912E+00, 0.7222523221E+00
        }
        
        geometry={ang
        Al
        Al, 1, 2.706
        Al, 2, 2.414, 1, 66.357
        Al, 2, 2.481, 1, 65.256, 3, 104.0
        Al, 3, 2.817, 2, 115.675, 1, 89.4
        Al, 1, 2.529, 2, 107.280, 3, 345.8
        Al, 5, 2.547, 3, 105.113, 2, 272.6
        Al, 7, 2.510, 5, 97.637, 3, 43.5
        Al, 5, 2.401, 3, 104.449, 2, 341.2
        Al, 4, 2.666, 2, 63.620, 1, 238.2
        }
        
        SET,CHARGE=0
        direct
        {ks, b3lyp,maxit=200}
        
        ---
        
        Respecting empty lines between different sections of the file. That is, it must have one empty line between
        each section of the file. Here we can see we can have until six sections in the file: the beggining's section or
        just '***,', the basis' section, the parameters' section (that can exists or don't), the geometry's section, 
        the settings' section and the end section or just '---'. The order of the sections also must respect the
        order of the chosen structure. The second structure, that is the structure with literal numbers inside the
        geometry brackets is not compatible with optg function, so the first structure, that is the one with declared
        variables before the geometry is aways recommended

        :param file: File name, it must end with .inp but the .inp may not be included here
        :type file: str
        :param rand_range: Min and max values that can be generated when distances are mutated, defaults to None
        :type rand_range: Tuple[numeric, numeric], optional
        :param label: A tag which can be used to identify the object, defaults to None
        :type label: str, optional
        :param output: The address of the molecule's .out document generated by Molpro, defaults to None
        :type output: str, optional
        :param output_values: Values extracted from the output document, defaults to dict()
        :type output_values: dict[str, numeric], optional
        :param was_optg: True if the geometry was already optmized with optg, false if it doesn't
        :type was_optg: bool, optional
        :raises Exception: Invalid Z-matrix
        :return: Loaded molecule
        :rtype: Molecule
        """
        with open(file, 'r') as data:
            inpstr = re.search('\*\*\*,.*---', data.read(), flags=re.S)[0]
        basis = re.search('basis=.*', inpstr, flags=re.S)[0].split('\n\n')[0].replace('basis=', '')
        splitinpstr = inpstr.split('\n\n')
        leninspstr = len(splitinpstr)
        if leninspstr == 6:
            parameters = {p.split('=')[0]:float(p.split('=')[1]) for p in splitinpstr[2].split('\n')}
            settings_location = 4
        elif leninspstr == 5:
            parameters = dict()
            settings_location = 3
        else:
            raise Exception('Invalid input format.')
        geometry = [re.split(' *, *', row) for row in re.search('geometry=.*', inpstr, flags=re.S)[0].split('\n\n')[0].\
                    replace('geometry=', '').replace('{', '').replace('}', '').split('\n')]
        geometry.remove([''])
        settings = splitinpstr[settings_location].split('\n')
        return Molecule(basis, geometry, settings, parameters, rand_range, label, output, output_values, was_optg)
    

def swap_mutate(molecule: Molecule, times: int = 1, label: str = None) -> Molecule:
    """Creates a molecule's copy and randomly swap parameters of its places. It makes a amount of random swaps equal 
    times.

    :param molecule: Original molecule
    :type molecule: Molecule
    :param times: Amount of random swaps, defaults to 1
    :type times: int, optional
    :param label: Label of the new molecule, defaults to None
    :type label: str, optional
    :return: New molecule
    :rtype: Molecule
    """
    if len(molecule.geometry) < 4:
        raise Exception('At least 3 atoms are needed')
    new_molecule = molecule.copy()
    for _ in range(times):
        indexes = new_molecule.random_compatible_indexes()
        index0, index1 = indexes[0]
        index2, index3 = indexes[1]
        if not new_molecule.geometry[index0][index1] in new_molecule.parameters.keys() and not\
            new_molecule.geometry[index2][index3] in new_molecule.parameters.keys():
            new_molecule.geometry[index0][index1], new_molecule.geometry[index2][index3] =\
                new_molecule.geometry[index2][index3], new_molecule.geometry[index0][index1]
        elif not new_molecule.geometry[index0][index1] in new_molecule.parameters.keys() and\
            new_molecule.geometry[index2][index3] in new_molecule.parameters.keys():
            new_molecule.geometry[index0][index1], new_molecule.parameters[new_molecule.geometry[index2][index3]] =\
                new_molecule.parameters[new_molecule.geometry[index2][index3]], new_molecule.geometry[index0][index1]
        elif new_molecule.geometry[index0][index1] in new_molecule.parameters.keys() and not\
            new_molecule.geometry[index2][index3] in new_molecule.parameters.keys():
            new_molecule.parameters[new_molecule.geometry[index0][index1]], new_molecule.geometry[index2][index3] =\
                new_molecule.geometry[index2][index3], new_molecule.parameters[new_molecule.geometry[index0][index1]]
        else:
            new_molecule.parameters[new_molecule.geometry[index0][index1]],\
                new_molecule.parameters[new_molecule.geometry[index2][index3]] =\
                    new_molecule.parameters[new_molecule.geometry[index2][index3]],\
                        new_molecule.parameters[new_molecule.geometry[index0][index1]]
    new_molecule.output = None
    new_molecule.output_values = dict()
    new_molecule.label = label
    new_molecule.was_optg = False
    return new_molecule


def mutate_angles(molecule: Molecule, times: int = 1, label: str = None) -> Molecule:
    """Creates a moecule's copy and randomly choices an angle parameter and set it value to a random value between 0 and
    360. The amount of mutations performed is equal times

    :param molecule: Original molecule
    :type molecule: Molecule
    :param times: Amount of angle mutations, defaults to 1
    :type times: int, optional
    :param label: Label of the new molecule, defaults to None
    :type label: str, optional
    :return: New molecule
    :rtype: Molecule
    """
    new_molecule = molecule.copy()
    for _ in range(times):
        index0 = random.choice(range(3, len(new_molecule.geometry)))
        index1 = random.choice(range(4, len(new_molecule.geometry[index0]) + 1, 2))
        if isinstance(new_molecule.geometry[index0][index1], (int, float)):
            new_molecule.geometry[index0][index1] = random.uniform(0, 360)
        else:
            new_molecule.parameters[new_molecule.geometry[index0][index1]] = random.uniform(0, 360)
    new_molecule.output = None
    new_molecule.output_values = dict()
    new_molecule.label = label
    new_molecule.was_optg = False
    return new_molecule


def mutate_distances(molecule: Molecule, times: int = 1, label: str = None) -> Molecule:
    """Creates a moecule's copy and randomly choices a distance parameter and set it value in the range gave by 
    rand_range. The amount of mutations performed is equal times

    :param molecule: Original molecule
    :type molecule: Molecule
    :param times: Amount of angle mutations, defaults to 1
    :type times: int, optional
    :param label: Label of the new molecule, defaults to None
    :type label: str, optional
    :return: New molecule
    :rtype: Molecule
    """
    new_molecule = molecule.copy()
    for _ in range(times):
        index0 = random.choice(range(2, len(new_molecule.geometry)))
        if isinstance(new_molecule.geometry[index0][2], (int, float)):
            new_molecule.geometry[index0][2] = new_molecule.random_distance()
        else:
            new_molecule.parameters[new_molecule.geometry[index0][2]] = new_molecule.random_distance()
    new_molecule.output = None
    new_molecule.output_values = dict()
    new_molecule.label = label
    new_molecule.was_optg = False
    return new_molecule


def random_molecule(molecular_formula: str, basis: str, settings: list[str], rand_range: Tuple[numeric, numeric], 
    label: str = None, dist_unit: str = 'ang') -> Molecule:
    """Creates a geometry with all distances parameters randomized in the range gave by rand_range and all angles 
    randomized between 0 and 360 given the molecular formula which is a string containing the elements followed by its 
    amount like'H2O', 'C6H12O6', 'Al10'... It doesn't support parenthesys and is invariant to the order of elements. 
    What matters in molecular_formula is which number follows which element

    :param molecular_formula: The molecular formula of the wanted molecule
    :type molecular_formula: str
    :param basis: Hilbert space basis
    :type basis: str
    :param settings: Molpro calculation settings
    :type settings: list[str]
    :param rand_range: Min and max values that can be generated when distances are mutated
    :type rand_range: Tuple[numeric, numeric]
    :param label: A tag which can be used to identify the molecule, defaults to None
    :type label: str, optional
    :param dist_unit: Distance unit, defaults to 'ang'
    :type dist_unit: str, optional
    :return: Random molecule
    :rtype: Molecule
    """
    atoms = re.findall('[A-Z][a-z]*[0-9]*', molecular_formula)
    geometry = [[dist_unit]]
    for atom in atoms:
        element = re.sub('[0-9]*', '', atom)
        times = re.sub('[A-Z][a-z]*', '', atom)
        if times:
            times = int(times)
        else:
            times = 1
        for t in range(times):
            geometry.append([element]) 
            if len(geometry) > 2:
                geometry[-1].append('1')
                geometry[-1].append(random.uniform(rand_range[0], rand_range[1]))
                if len(geometry) > 3:
                    for n in (2, 3):
                        geometry[-1].append((str(n)))
                        geometry[-1].append(random.uniform(0, 360))
    return Molecule(basis, geometry, settings, rand_range=rand_range, label=label)


def crossover_n(parent: Molecule, donor: Molecule, label: str = None) -> Molecule:
    """Creates a copy of the parent molecule, randomly choices an amount of parameters the minimun being one and the 
    maximun being the total amount of parameters minus one. Then randomly choices this amount of parameters from the 
    donor molecule to replace the respectives parameters the child molecule inherited from parent molecule

    :param parent: Parent molecule
    :type parent: Molecule
    :param donor: Donor molecule
    :type donor: Molecule
    :param label: A tag which can be used to identify the child molecule, defaults to None
    :type label: str, optional
    :return: Child molecule
    :rtype: Molecule
    """
    if len(parent.geometry) < 4:
        raise Exception('At least 3 atoms are needed')
    child = parent.copy()
    total_n_parameters = 3 + 3 * len(parent.geometry[4:])
    n_parameters = random.randint(1, total_n_parameters - 1)
    chosen_parameters = random.sample(child.parameters_indexes, n_parameters)
    __crossover_executor(child, donor, chosen_parameters)
    child.label = label
    child.output = None
    child.output_values = dict()
    child.was_optg = False
    return child


def randomize(molecule: Molecule, label: str = None) -> Molecule:
    """Creates a molecule's copy and replace all distance parameters with random values in the range gave by rand_range 
    and replace all angle parameters with random values between 0 and 360

    :param molecule: Original molecule
    :type molecule: Molecule
    :param label: A tag which can be used to identify the new molecule, defaults to None
    :type label: str, optional
    :return: New molecule
    :rtype: Molecule
    """
    new_molecule = molecule.copy()
    new_molecule.label = label
    for row_index in range(2, len(new_molecule.geometry)):
        if isinstance(new_molecule.geometry[row_index][2], (int, float)):
            new_molecule.geometry[row_index][2] = new_molecule.random_distance()
        else:
            new_molecule.parameters[new_molecule.geometry[row_index][2]] = new_molecule.random_distance()
        for angle_index in range(4, len(new_molecule.geometry[row_index]), 2):
            if isinstance(new_molecule.geometry[row_index][angle_index], (int, float)):
                new_molecule.geometry[row_index][angle_index] = random.uniform(0, 360)
            else:
                new_molecule.parameters[new_molecule.geometry[row_index][angle_index]] = random.uniform(0, 360)
    new_molecule.output = None
    new_molecule.output_values = dict()
    new_molecule.was_optg = False
    return new_molecule


def crossover_1(parent: Molecule, donor: Molecule, label: str = None) -> Molecule:
    """Creates a copy of the parent molecule then randomly choices a row and a 'column' from the geometry and there 
    divides the geometry in two pieces. Then randomly pick one of these pieces and attach with the complementar part 
    provided by the donor molecule generating the geometry of the child molecule

    :param parent: Parent molecule
    :type parent: Molecule
    :param donor: Donor molecule
    :type donor: Molecule
    :param label: A tag which can be used to identify the child molecule, defaults to None
    :type label: str, optional
    :return: Child molecule
    :rtype: Molecule
    """
    if len(parent.geometry) < 4:
        raise Exception('At least 3 atoms are needed')
    child = parent.copy()
    cutoff_index = random.randint(1, len(child.parameters_indexes) - 2)
    if bool(random.getrandbits(1)):
        chosen_parameters = child.parameters_indexes[cutoff_index:]
    else:
        chosen_parameters = child.parameters_indexes[:cutoff_index]
    __crossover_executor(child, donor, chosen_parameters)
    child.label = label
    child.output = None
    child.output_values = dict()
    child.was_optg = False
    return child


def crossover_2(parent: Molecule, donor: Molecule, label: str = None) -> Molecule:
    """Randomly cuts the parent molecule's geometry in two points. The sequence between these two points will either 
    replace its correspondent in the donor molecule's geometry or be replaced by it (randomly) generating the geometry
    of the child molecule that will be returned. At leas four atoms are needed to realize this process. Trying it with
    molecules smaller than it will raise an exception

    :param parent: Parent molecule
    :type parent: Molecule
    :param donor: Donor molecule
    :type donor: Molecule
    :param label: A tag which can be used to identify the child molecule, defaults to None
    :type label: str, optional
    :raises Exception: At least 4 atoms are needed to perform crossover_2
    :return: child Molecule
    :rtype: Molecule
    """
    if len(parent.geometry) < 5:
        raise Exception('At least 4 atoms are needed')
    child = parent.copy()
    indexes = random.sample(range(1, len(child.parameters_indexes) - 1), 2)
    indexes.sort()
    if bool(random.getrandbits(1)):
        chosen_parameters = child.parameters_indexes[indexes[0]:indexes[1]]
    else:
        chosen_parameters = child.parameters_indexes[:indexes[0]] + child.parameters_indexes[indexes[1]:]
    __crossover_executor(child, donor, chosen_parameters)
    child.label = label
    child.output = None
    child.output_values = dict()
    child.was_optg = False
    return child


def __crossover_executor(child: Molecule, donor: Molecule, params_indexes: list[list[int, int]]) -> None:
    """Executes the crossover operation by filtering if it either must ne done directly in the geometry or indirectly in
    the parameters dictionary

    :param child: Child Molecule, which is a deepcopy of the parent Molecule
    :type child: Molecule
    :param donor: Donor Molecule
    :type donor: Molecule
    :param params_indexes: list of the parameters' indexes of the child molecule that will be replaced by donor's
        parameters
    :type params_indexes: list[list[int, int]]
    """
    for indexes in params_indexes:
        if child.geometry[indexes[0]][indexes[1]] in child.parameters.keys() and\
            donor.geometry[indexes[0]][indexes[1]] in donor.parameters.keys():
            child.parameters[child.geometry[indexes[0]][indexes[1]]] =\
                donor.parameters[donor.geometry[indexes[0]][indexes[1]]]
        elif not child.geometry[indexes[0]][indexes[1]] in child.parameters.keys() and\
            donor.geometry[indexes[0]][indexes[1]] in donor.parameters.keys():
            child.geometry[indexes[0]][indexes[1]] =\
                donor.parameters[donor.geometry[indexes[0]][indexes[1]]]
        elif child.geometry[indexes[0]][indexes[1]] in child.parameters.keys() and not\
            donor.geometry[indexes[0]][indexes[1]] in donor.parameters.keys():
            child.parameters[child.geometry[indexes[0]][indexes[1]]] =\
                donor.geometry[indexes[0]][indexes[1]]
        else:
            child.geometry[indexes[0]][indexes[1]] = donor.geometry[indexes[0]][indexes[1]]


def atom_displacement_mutate(molecule: Molecule, times: int = 1, label: str = None) -> Molecule:
    """Creates a new molecule which will be a copy of the input molecule with one random atom randomly displaced. It
    will randomly select an atom and randomly change all it's positional parameters

    :param molecule: Parent Molecule
    :type molecule: Molecule
    :param times: Amount of random displacements that will be realized, defaults to 1
    :type times: int, optional
    :param label: A tag which can be used to identify the child molecule, defaults to None
    :type label: str, optional
    :raises Exception: Raises an exception if there are less than two atoms
    :return: Child Molecule
    :rtype: Molecule
    """
    if len(molecule.geometry) < 3:
        raise Exception("At least two atoms are needed")
    new_molecule = molecule.copy()
    for _ in range(times):
        atom_index = random.choice(range(len(molecule.geometry[2:]))) + 2
        if atom_index == 2:
            if new_molecule.geometry[2][2] in new_molecule.parameters.keys():
                new_molecule.parameters[new_molecule.geometry[2][2]] = new_molecule.random_distance()
            else:
                new_molecule.geometry[2][2] = new_molecule.random_distance()
        if atom_index == 3:
            if new_molecule.geometry[3][2] in new_molecule.parameters.keys():
                new_molecule.parameters[new_molecule.geometry[3][2]] = new_molecule.random_distance()
            else:
                new_molecule.geometry[3][2] = new_molecule.random_distance()
            if new_molecule.geometry[3][4] in new_molecule.parameters.keys():
                new_molecule.parameters[new_molecule.geometry[3][4]] = random.uniform(0, 360)
            else:
                new_molecule.geometry[3][4] = random.uniform(0, 360)
        if atom_index > 3:
            if new_molecule.geometry[atom_index][2] in new_molecule.parameters.keys():
                new_molecule.parameters[new_molecule.geometry[atom_index][2]] = new_molecule.random_distance()
            else:
                new_molecule.geometry[atom_index][2] = new_molecule.random_distance()
            if new_molecule.geometry[atom_index][4] in new_molecule.parameters.keys():
                new_molecule.parameters[new_molecule.geometry[atom_index][4]] = random.uniform(0, 360)
            else:
                new_molecule.geometry[atom_index][4] = random.uniform(0, 360)
            if new_molecule.geometry[atom_index][6] in new_molecule.parameters.keys():
                new_molecule.parameters[new_molecule.geometry[atom_index][6]] = random.uniform(0, 360)
            else:
                new_molecule.geometry[atom_index][6] = random.uniform(0, 360)
    new_molecule.label = label
    return new_molecule


def optg(molecule: Molecule, wanted_energy: str, directory: str = 'data', nthreads: int = 1, 
    keep_output: bool = False) -> Molecule:
    """Creates a copy of the original molecule, appends 'optg' in the settings if it's not already there and calls the 
    get_value function with it. Then updates the wanted_energy in optmized_molecule.output_values and updates all angles
    and distances parameters in [optmized_molecule.parameters]. To use this function there cannont be any literal value 
    in the molecule's geometry, all values must be as variables names in geometry and has its literal values declared in
    molecule.parameters

    :param molecule: Original molecule
    :type molecule: Molecule
    :param wanted_energy: The key wanted for the energy in optimized_molecule.output_values
    :type wanted_energy: str
    :param directory: Directory adress where the input and the output will be relative to __main__, defaults to 'data'
    :type directory: str, optional
    :param nthreads: Number of threads useds in Molpro calculation, defaults to 1
    :type nthreads: int, optional
    :param keep_output: If it's True, the output will be kept and its name will be put in self.output, else it will be 
        deleted after is read. defaults to False
    :type keep_output: bool, optional
    :return: Optmized molecule
    :rtype: Molecule
    """
    opt_molecule = molecule.copy()
    if molecule.label is None:
        opt_molecule.label = str(opt_molecule.__hash__())
    opt_molecule.label += '_optg'
    if not 'optg' in opt_molecule.settings:
        opt_molecule.settings.append('optg')
    if not 'total_energy = energy' in opt_molecule.settings:
        opt_molecule.settings.append('total_energy = energy')
    opt_molecule.output_values.update({wanted_energy: opt_molecule.get_value(['TOTAL_ENERGY'], keep_output=True, 
        nthreads=nthreads, update_self=False)['TOTAL_ENERGY']})
    with open(f'{directory}/{opt_molecule.label}.out', 'r') as file:
        outstr = file.read()
        for parameter in opt_molecule.parameters.keys():
            opt_molecule.parameters[parameter] = re.search('-*[0-9.]+', re.sub(parameter, '', 
                re.findall(f'{parameter}=.*', outstr, flags=re.I)[1], flags=re.I))[0]
    opt_molecule.settings.remove('optg')
    opt_molecule.settings.remove('total_energy = energy')
    if not keep_output:
        os.remove(f'{directory}/{opt_molecule.label}.log')
        os.remove(f'{directory}/{opt_molecule.label}.xml')
        os.remove(f'{directory}/{opt_molecule.label}.out')
    else:
        opt_molecule.output = f'{directory}/{opt_molecule.label}.out'
    if molecule.label is None:
        opt_molecule.label = None
    opt_molecule.was_optg = True
    return opt_molecule


def ieq_mutate(molecule: Molecule, times: int = 1, label: str = None) -> Molecule:
    """Returns a new molecule which will be a copy of the input molecule which will have two random parameters
    equalized. The parameters chosen will be compatible, it means, the both will be either distance parameters or angle
    distance

    :param molecule: Parent molecule
    :type molecule: Molecule
    :param times: amount of random equalizations, defaults to 1
    :type times: int, optional
    :param label: A tag which can be used to identify the child molecule, defaults to None
    :type label: str, optional
    :raises Exception: Raises an exception if there are less than three atoms
    :return: Child Molecule
    :rtype: Molecule
    """
    if len(molecule.geometry) < 4:
        raise Exception('At least 3 atoms are needed')
    new_molecule = molecule.copy()
    for _ in range(times):
        indexes = new_molecule.random_compatible_indexes()
        index0, index1 = indexes[0]
        index2, index3 = indexes[1]
        if not new_molecule.geometry[index0][index1] in new_molecule.parameters.keys() and not\
            new_molecule.geometry[index2][index3] in new_molecule.parameters.keys():
            new_molecule.geometry[index0][index1] = new_molecule.geometry[index2][index3]
        elif not new_molecule.geometry[index0][index1] in new_molecule.parameters.keys() and\
            new_molecule.geometry[index2][index3] in new_molecule.parameters.keys():
            new_molecule.geometry[index0][index1] = new_molecule.parameters[new_molecule.geometry[index2][index3]]
        elif new_molecule.geometry[index0][index1] in new_molecule.parameters.keys() and not\
            new_molecule.geometry[index2][index3] in new_molecule.parameters.keys():
            new_molecule.parameters[new_molecule.geometry[index0][index1]] = new_molecule.geometry[index2][index3]
        else:
            new_molecule.parameters[new_molecule.geometry[index0][index1]] =\
                new_molecule.parameters[new_molecule.geometry[index2][index3]]
    new_molecule.label = label
    new_molecule.output = None
    new_molecule.output_values = dict()
    new_molecule.was_optg = False
    return new_molecule


def atom_swap_mutate(molecule: Molecule, times: int = 1, label: str = None) -> Molecule:
    """Returns a new molecule which will be a copy of the input molecule with two atom with swapped positions

    :param molecule: Parent molecule
    :type molecule: Molecule
    :param times: The amount of position swaps that will occur, defaults to 1
    :type times: int, optional
    :param label: A tag which can be used to identify the child molecule, defaults to None
    :type label: str, optional
    :raises Exception: Raises an exception if there are less than two atoms
    :return: Child molecule
    :rtype: Molecule
    """
    if len(molecule.geometry) < 3:
        raise Exception('At least 2 atoms are needed')
    new_molecule = molecule.copy()
    for _ in range(times):
        atoms_indexes = [n + 1 for n in range(len(new_molecule.geometry) - 1)]
        indexes = random.sample(atoms_indexes, 2)
        while new_molecule.geometry[indexes[0]][0] == new_molecule.geometry[indexes[1]][0]:
            indexes = random.sample(atoms_indexes, 2)
        new_molecule.geometry[indexes[0]][0], new_molecule.geometry[indexes[1]][0] =\
            new_molecule.geometry[indexes[1]][0], new_molecule.geometry[indexes[0]][0]
    new_molecule.label = label
    new_molecule.output = None
    new_molecule.output_values = dict()
    new_molecule.was_optg = False
    return new_molecule
